items:
- uid: System.Threading.Tasks.Task
  commentId: T:System.Threading.Tasks.Task
  id: Task
  parent: System.Threading.Tasks
  children:
  - System.Threading.Tasks.Task.#ctor(System.Action)
  - System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)
  - System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)
  - System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)
  - System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)
  - System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)
  - System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)
  - System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)
  - System.Threading.Tasks.Task.AsyncState
  - System.Threading.Tasks.Task.CompletedTask
  - System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)
  - System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)
  - System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)
  - System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)
  - System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)
  - System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)
  - System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})
  - System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)
  - System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)
  - System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)
  - System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)
  - System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})
  - System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)
  - System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)
  - System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)
  - System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)
  - System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)
  - System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)
  - System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)
  - System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)
  - System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)
  - System.Threading.Tasks.Task.CreationOptions
  - System.Threading.Tasks.Task.CurrentId
  - System.Threading.Tasks.Task.Delay(System.Int32)
  - System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)
  - System.Threading.Tasks.Task.Delay(System.TimeSpan)
  - System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)
  - System.Threading.Tasks.Task.Exception
  - System.Threading.Tasks.Task.Factory
  - System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)
  - System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)
  - System.Threading.Tasks.Task.FromException(System.Exception)
  - System.Threading.Tasks.Task.FromException``1(System.Exception)
  - System.Threading.Tasks.Task.FromResult``1(``0)
  - System.Threading.Tasks.Task.GetAwaiter
  - System.Threading.Tasks.Task.Id
  - System.Threading.Tasks.Task.IsCanceled
  - System.Threading.Tasks.Task.IsCompleted
  - System.Threading.Tasks.Task.IsFaulted
  - System.Threading.Tasks.Task.Run(System.Action)
  - System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)
  - System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})
  - System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)
  - System.Threading.Tasks.Task.Run``1(System.Func{``0})
  - System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)
  - System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})
  - System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)
  - System.Threading.Tasks.Task.RunSynchronously
  - System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)
  - System.Threading.Tasks.Task.Start
  - System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)
  - System.Threading.Tasks.Task.Status
  - System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle
  - System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously
  - System.Threading.Tasks.Task.Wait
  - System.Threading.Tasks.Task.Wait(System.Int32)
  - System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)
  - System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)
  - System.Threading.Tasks.Task.Wait(System.TimeSpan)
  - System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])
  - System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)
  - System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)
  - System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)
  - System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)
  - System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])
  - System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)
  - System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)
  - System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)
  - System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)
  - System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})
  - System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])
  - System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})
  - System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])
  - System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})
  - System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])
  - System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})
  - System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])
  - System.Threading.Tasks.Task.Yield
  langs:
  - csharp
  - vb
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
  type: Class
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Task
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 139
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Represents an asynchronous operation.</p>\n<p>To browse the .NET Framework source code for this type, see the <see href=\"http://referencesource.microsoft.com/#mscorlib/system/threading/Tasks/Task.cs#045a746eb48cbaa9\">Reference Source</see>.</p>\n"
  remarks: "\n<p>To view the .NET Framework source code for this type, see the <see href=\"http://referencesource.microsoft.com/#mscorlib/system/threading/Tasks/Task.cs#045a746eb48cbaa9\">Reference Source</see>. You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <see href=\"http://referencesource.microsoft.com/\">instructions</see>.</p>\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> class represents a single operation that does not return a value and that usually executes asynchronously. <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> objects are one of the central components of the  task-based asynchronous pattern first introduced in the .NET Framework 4. Because the work performed by a <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> object typically executes asynchronously on a thread pool thread rather than synchronously on the main application thread, you can use the <xref href=\"System.Threading.Tasks.Task.Status\" data-throw-if-not-resolved=\"false\"></xref> property, as well as the <xref href=\"System.Threading.Tasks.Task.IsCanceled\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Threading.Tasks.Task.IsCompleted\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Threading.Tasks.Task.IsFaulted\" data-throw-if-not-resolved=\"false\"></xref> properties, to determine the   state of a task. Most commonly, a lambda expression is used to specify the work that the task is to perform. </p>\n<p>For operations that return values, you use the <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref> class. </p>\n<p>In this section:</p>\n<p>Creating and executing a taskSeparating task creation and executionWaiting for one or more tasks to completeTasks and cultureFor debugger developers</p>\n"
  syntax:
    content: >-
      [HostProtection(Synchronization = true, ExternalThreading = true)]

      [DebuggerTypeProxy(typeof (SystemThreadingTasks_TaskDebugView))]

      [DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")]

      public class Task : IThreadPoolWorkItem, IAsyncResult, IDisposable
    content.vb: >-
      <HostProtection(Synchronization:=True, ExternalThreading:=True)>

      <DebuggerTypeProxy(GetType(SystemThreadingTasks_TaskDebugView))>

      <DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")>

      Public Class Task
          Implements IThreadPoolWorkItem, IAsyncResult, IDisposable
  seealso:
  - type: System.Threading.Tasks.Task`1
    commentId: T:System.Threading.Tasks.Task`1
  inheritance:
  - System.Object
  implements:
  - System.IAsyncResult
  inheritedMembers:
  - System.Object.ToString
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  modifiers.csharp:
  - public
  - class
  modifiers.vb:
  - Public
  - Class
- uid: System.Threading.Tasks.Task.#ctor(System.Action)
  commentId: M:System.Threading.Tasks.Task.#ctor(System.Action)
  id: '#ctor(System.Action)'
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Task(Action)
  nameWithType: Task.Task(Action)
  fullName: System.Threading.Tasks.Task.Task(System.Action)
  type: Constructor
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: .ctor
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 368
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Initializes a new <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> with the specified action.</p>\n"
  remarks: "\n<p>Rather than calling this constructor, the most common way to instantiate a <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> object and launch a task is by calling the static <xref href=\"System.Threading.Tasks.Task.Run(System.Action)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Threading.Tasks.TaskFactory.StartNew(System.Action)\" data-throw-if-not-resolved=\"false\"></xref> method. The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation. </p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task(Action action)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Sub New(action As Action)
    parameters:
    - id: action
      type: System.Action
      description: "\n<p>The delegate that represents the code to execute in the task.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>action</em> argument is <strong>null</strong>.</p>\n"
  seealso:
  - type: System.Threading.Tasks.Task.Run(System.Action)
    commentId: M:System.Threading.Tasks.Task.Run(System.Action)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)
  commentId: M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)
  id: '#ctor(System.Action,System.Threading.CancellationToken)'
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Task(Action, CancellationToken)
  nameWithType: Task.Task(Action, CancellationToken)
  fullName: System.Threading.Tasks.Task.Task(System.Action, System.Threading.CancellationToken)
  type: Constructor
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: .ctor
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 386
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Initializes a new <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> with the specified action and <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>Rather than calling this constructor, the most common way to instantiate a <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> object and launch a task is by calling the static <xref href=\"System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken)\" data-throw-if-not-resolved=\"false\"></xref> methods. The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation. </p>\n<p>For more information, see Task Parallelism (Task Parallel Library) and Cancellation in Managed Threads.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task(Action action, CancellationToken cancellationToken)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Sub New(action As Action, cancellationToken As CancellationToken)
    parameters:
    - id: action
      type: System.Action
      description: "\n<p>The delegate that represents the code to execute in the task.</p>\n"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\n<p>The <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> that the new  task will observe.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The provided <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> has already been disposed. </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>action</em> argument is null.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)
  commentId: M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)
  id: '#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)'
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Task(Action, CancellationToken, TaskCreationOptions)
  nameWithType: Task.Task(Action, CancellationToken, TaskCreationOptions)
  fullName: System.Threading.Tasks.Task.Task(System.Action, System.Threading.CancellationToken, System.Threading.Tasks.TaskCreationOptions)
  type: Constructor
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: .ctor
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 436
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Initializes a new <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> with the specified action and creation options.</p>\n"
  remarks: "\n<p>Rather than calling this constructor, the most common way to instantiate a <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> object and launch a task is by calling the static <xref href=\"System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)\" data-throw-if-not-resolved=\"false\"></xref> method. The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation. </p>\n<p>For more information, see Task Parallelism (Task Parallel Library) and Task Cancellation.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Sub New(action As Action, cancellationToken As CancellationToken, creationOptions As TaskCreationOptions)
    parameters:
    - id: action
      type: System.Action
      description: "\n<p>The delegate that represents the code to execute in the task.</p>\n"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\n<p>The <xref href=\"System.Threading.Tasks.TaskFactory.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> that the new task will observe.</p>\n"
    - id: creationOptions
      type: System.Threading.Tasks.TaskCreationOptions
      description: "\n<p>The <xref href=\"System.Threading.Tasks.TaskCreationOptions\" data-throw-if-not-resolved=\"false\"></xref> used to customize the task's behavior.</p>\n<p></p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> that created <em>cancellationToken</em> has already been disposed.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>action</em> argument is null.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The <em>creationOptions</em> argument specifies an invalid value for <xref href=\"System.Threading.Tasks.TaskCreationOptions\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)
  commentId: M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)
  id: '#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)'
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Task(Action, TaskCreationOptions)
  nameWithType: Task.Task(Action, TaskCreationOptions)
  fullName: System.Threading.Tasks.Task.Task(System.Action, System.Threading.Tasks.TaskCreationOptions)
  type: Constructor
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: .ctor
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 409
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Initializes a new <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> with the specified action and creation options.</p>\n"
  remarks: "\n<p>Rather than calling this constructor, the most common way to instantiate a <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> object and launch a task is by calling the static <xref href=\"System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.Tasks.TaskCreationOptions)\" data-throw-if-not-resolved=\"false\"></xref> method. The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation. </p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task(Action action, TaskCreationOptions creationOptions)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Sub New(action As Action, creationOptions As TaskCreationOptions)
    parameters:
    - id: action
      type: System.Action
      description: "\n<p>The delegate that represents the code to execute in the task.</p>\n"
    - id: creationOptions
      type: System.Threading.Tasks.TaskCreationOptions
      description: "\n<p>The <xref href=\"System.Threading.Tasks.TaskCreationOptions\" data-throw-if-not-resolved=\"false\"></xref> used to customize the task's behavior. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>action</em> argument is null.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The <em>creationOptions</em> argument specifies an invalid value for <xref href=\"System.Threading.Tasks.TaskCreationOptions\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)
  commentId: M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)
  id: '#ctor(System.Action{System.Object},System.Object)'
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Task(Action<Object>, Object)
  nameWithType: Task.Task(Action<Object>, Object)
  fullName: System.Threading.Tasks.Task.Task(System.Action<System.Object>, System.Object)
  type: Constructor
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: .ctor
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 453
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Initializes a new <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> with the specified action and state.</p>\n"
  remarks: "\n<p>Rather than calling this constructor, the most common way to instantiate a <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> object and launch a task is by calling the static <xref href=\"System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method. The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation. </p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task(Action<object> action, object state)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Sub New(action As Action(Of Object), state As Object)
    parameters:
    - id: action
      type: System.Action{System.Object}
      description: "\n<p>The delegate that represents the code to execute in the task.</p>\n"
    - id: state
      type: System.Object
      description: "\n<p>An object representing data to be used by the action.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>action</em> argument is null.</p>\n"
  seealso:
  - type: System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)
    commentId: M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)
  nameWithType.vb: Task.Task(Action(Of Object), Object)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.Tasks.Task.Task(System.Action(Of System.Object), System.Object)
  name.vb: Task(Action(Of Object), Object)
- uid: System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)
  commentId: M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)
  id: '#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)'
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Task(Action<Object>, Object, CancellationToken)
  nameWithType: Task.Task(Action<Object>, Object, CancellationToken)
  fullName: System.Threading.Tasks.Task.Task(System.Action<System.Object>, System.Object, System.Threading.CancellationToken)
  type: Constructor
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: .ctor
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 473
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Initializes a new <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> with the specified action, state, and options.</p>\n"
  remarks: "\n<p>Rather than calling this constructor, the most common way to instantiate a <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> object and launch a task is by calling the static <xref href=\"System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken)\" data-throw-if-not-resolved=\"false\"></xref> method. The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation. </p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task(Action<object> action, object state, CancellationToken cancellationToken)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Sub New(action As Action(Of Object), state As Object, cancellationToken As CancellationToken)
    parameters:
    - id: action
      type: System.Action{System.Object}
      description: "\n<p>The delegate that represents the code to execute in the task.</p>\n"
    - id: state
      type: System.Object
      description: "\n<p>An object representing data to be used by the action.</p>\n"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\n<p>The <xref href=\"System.Threading.Tasks.TaskFactory.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> that that the new task will observe.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> that created <em>cancellationToken</em> has already been disposed.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>action</em> argument is null.</p>\n"
  nameWithType.vb: Task.Task(Action(Of Object), Object, CancellationToken)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.Tasks.Task.Task(System.Action(Of System.Object), System.Object, System.Threading.CancellationToken)
  name.vb: Task(Action(Of Object), Object, CancellationToken)
- uid: System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)
  commentId: M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)
  id: '#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)'
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Task(Action<Object>, Object, CancellationToken, TaskCreationOptions)
  nameWithType: Task.Task(Action<Object>, Object, CancellationToken, TaskCreationOptions)
  fullName: System.Threading.Tasks.Task.Task(System.Action<System.Object>, System.Object, System.Threading.CancellationToken, System.Threading.Tasks.TaskCreationOptions)
  type: Constructor
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: .ctor
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 525
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Initializes a new <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> with the specified action, state, and options.</p>\n"
  remarks: "\n<p>Rather than calling this constructor, the most common way to instantiate a <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> object and launch a task is by calling the static <xref href=\"System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)\" data-throw-if-not-resolved=\"false\"></xref> method. The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation. </p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task(Action<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Sub New(action As Action(Of Object), state As Object, cancellationToken As CancellationToken, creationOptions As TaskCreationOptions)
    parameters:
    - id: action
      type: System.Action{System.Object}
      description: "\n<p>The delegate that represents the code to execute in the task.</p>\n"
    - id: state
      type: System.Object
      description: "\n<p>An object representing data to be used by the action.</p>\n"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\n<p>The <xref href=\"System.Threading.Tasks.TaskFactory.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> that that the new task will observe..</p>\n"
    - id: creationOptions
      type: System.Threading.Tasks.TaskCreationOptions
      description: "\n<p>The <xref href=\"System.Threading.Tasks.TaskCreationOptions\" data-throw-if-not-resolved=\"false\"></xref> used to customize the task's behavior.</p>\n<p></p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> that created <em>cancellationToken</em> has already been disposed.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>action</em> argument is null.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The <em>creationOptions</em> argument specifies an invalid value for <xref href=\"System.Threading.Tasks.TaskCreationOptions\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  nameWithType.vb: Task.Task(Action(Of Object), Object, CancellationToken, TaskCreationOptions)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.Tasks.Task.Task(System.Action(Of System.Object), System.Object, System.Threading.CancellationToken, System.Threading.Tasks.TaskCreationOptions)
  name.vb: Task(Action(Of Object), Object, CancellationToken, TaskCreationOptions)
- uid: System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)
  commentId: M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)
  id: '#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)'
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Task(Action<Object>, Object, TaskCreationOptions)
  nameWithType: Task.Task(Action<Object>, Object, TaskCreationOptions)
  fullName: System.Threading.Tasks.Task.Task(System.Action<System.Object>, System.Object, System.Threading.Tasks.TaskCreationOptions)
  type: Constructor
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: .ctor
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 497
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Initializes a new <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> with the specified action, state, and options.</p>\n"
  remarks: "\n<p>Rather than calling this constructor, the most common way to instantiate a <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> object and launch a task is by calling the static <xref href=\"System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)\" data-throw-if-not-resolved=\"false\"></xref> method. The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task(Action<object> action, object state, TaskCreationOptions creationOptions)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Sub New(action As Action(Of Object), state As Object, creationOptions As TaskCreationOptions)
    parameters:
    - id: action
      type: System.Action{System.Object}
      description: "\n<p>The delegate that represents the code to execute in the task.</p>\n"
    - id: state
      type: System.Object
      description: "\n<p>An object representing data to be used by the action.</p>\n"
    - id: creationOptions
      type: System.Threading.Tasks.TaskCreationOptions
      description: "\n<p>The <xref href=\"System.Threading.Tasks.TaskCreationOptions\" data-throw-if-not-resolved=\"false\"></xref> used to customize the task's behavior.</p>\n<p></p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>action</em> argument is null.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The <em>creationOptions</em> argument specifies an invalid value for <xref href=\"System.Threading.Tasks.TaskCreationOptions\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  nameWithType.vb: Task.Task(Action(Of Object), Object, TaskCreationOptions)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.Tasks.Task.Task(System.Action(Of System.Object), System.Object, System.Threading.Tasks.TaskCreationOptions)
  name.vb: Task(Action(Of Object), Object, TaskCreationOptions)
- uid: System.Threading.Tasks.Task.AsyncState
  commentId: P:System.Threading.Tasks.Task.AsyncState
  id: AsyncState
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: AsyncState
  nameWithType: Task.AsyncState
  fullName: System.Threading.Tasks.Task.AsyncState
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: AsyncState
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 1587
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Gets the state object supplied when the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> was created, or null if none was supplied.</p>\n"
  remarks: "\n<p>Cast the object back to the original type to retrieve its data.</p>\n"
  syntax:
    content: public object AsyncState { get; }
    content.vb: Public ReadOnly Property AsyncState As Object
    parameters: []
    return:
      type: System.Object
      description: "\n<p>An <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> that represents the state data that was passed in to the task when it was created.</p>\n"
  implements:
  - System.IAsyncResult.AsyncState
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.Tasks.Task.CompletedTask
  commentId: P:System.Threading.Tasks.Task.CompletedTask
  id: CompletedTask
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: CompletedTask
  nameWithType: Task.CompletedTask
  fullName: System.Threading.Tasks.Task.CompletedTask
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: CompletedTask
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 1627
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Gets a task that has already completed successfully. </p>\n"
  remarks: "\n<p>This property returns a task whose <xref href=\"System.Threading.Tasks.Task.Status\" data-throw-if-not-resolved=\"false\"></xref> property is set to <xref href=\"System.Threading.Tasks.TaskStatus.RanToCompletion\" data-throw-if-not-resolved=\"false\"></xref>. To create task that returns a value and runs to completion, call the <xref href=\"System.Threading.Tasks.Task.FromResult``1(``0)\" data-throw-if-not-resolved=\"false\"></xref> method. </p>\n<p>Repeated attempts to retrieve this property value may not always return the same instance. </p>\n"
  syntax:
    content: public static Task CompletedTask { get; }
    content.vb: Public Shared ReadOnly Property CompletedTask As Task
    parameters: []
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>The successfully completed task. </p>\n"
  seealso:
  - type: System.Threading.Tasks.Task.FromResult``1(``0)
    commentId: M:System.Threading.Tasks.Task.FromResult``1(``0)
  modifiers.csharp:
  - public
  - static
  - get
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Threading.Tasks.Task.CreationOptions
  commentId: P:System.Threading.Tasks.Task.CreationOptions
  id: CreationOptions
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: CreationOptions
  nameWithType: Task.CreationOptions
  fullName: System.Threading.Tasks.Task.CreationOptions
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: CreationOptions
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 1551
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Gets the <xref href=\"System.Threading.Tasks.TaskCreationOptions\" data-throw-if-not-resolved=\"false\"></xref> used to create this task.</p>\n"
  syntax:
    content: public TaskCreationOptions CreationOptions { get; }
    content.vb: Public ReadOnly Property CreationOptions As TaskCreationOptions
    parameters: []
    return:
      type: System.Threading.Tasks.TaskCreationOptions
      description: "\n<p>The <xref href=\"System.Threading.Tasks.TaskCreationOptions\" data-throw-if-not-resolved=\"false\"></xref> used to create this task.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.Tasks.Task.CurrentId
  commentId: P:System.Threading.Tasks.Task.CurrentId
  id: CurrentId
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: CurrentId
  nameWithType: Task.CurrentId
  fullName: System.Threading.Tasks.Task.CurrentId
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: CurrentId
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 1332
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Returns the ID of the currently executing <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Threading.Tasks.Task.CurrentId\" data-throw-if-not-resolved=\"false\"></xref> is a <strong>static</strong> (<strong>Shared</strong> in Visual Basic) property that is used to get the identifier of the currently executing task from the code that the task is executing. It differs from the <xref href=\"System.Threading.Tasks.Task.Id\" data-throw-if-not-resolved=\"false\"></xref> property, which returns the identifier of a particular <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instance. If you attempt to retrieve the <xref href=\"System.Threading.Tasks.Task.CurrentId\" data-throw-if-not-resolved=\"false\"></xref> value from outside the code that a task is executing, the property returns <strong>null</strong>. </p>\n<p>Note that although collisions are very rare, task identifiers are not guaranteed to be unique. </p>\n"
  syntax:
    content: public static int ? CurrentId { get; }
    content.vb: Public Shared ReadOnly Property CurrentId As Integer?
    parameters: []
    return:
      type: System.Nullable{System.Int32}
      description: "\n<p>An integer that was assigned by the system to the currently-executing task.</p>\n"
  seealso:
  - type: System.Threading.Tasks.Task.Id
    commentId: P:System.Threading.Tasks.Task.Id
  modifiers.csharp:
  - public
  - static
  - get
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Threading.Tasks.Task.Exception
  commentId: P:System.Threading.Tasks.Task.Exception
  id: Exception
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Exception
  nameWithType: Task.Exception
  fullName: System.Threading.Tasks.Task.Exception
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Exception
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 1393
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Gets the <xref href=\"System.AggregateException\" data-throw-if-not-resolved=\"false\"></xref> that caused the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> to end prematurely. If the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completed successfully or has not yet thrown any exceptions, this will return <strong>null</strong>.</p>\n"
  remarks: "\n<p>Tasks that throw unhandled exceptions store the resulting exception and propagate it wrapped in a <xref href=\"System.AggregateException\" data-throw-if-not-resolved=\"false\"></xref> in calls to <xref href=\"System.Threading.Tasks.Task.Wait\" data-throw-if-not-resolved=\"false\"></xref> or in accesses to the <xref href=\"System.Threading.Tasks.Task.Exception\" data-throw-if-not-resolved=\"false\"></xref> property. Any exceptions not observed by the time the task instance is garbage collected will be propagated on the finalizer thread. For more information and an example, see Exception Handling (Task Parallel Library).</p>\n"
  syntax:
    content: public AggregateException Exception { get; }
    content.vb: Public ReadOnly Property Exception As AggregateException
    parameters: []
    return:
      type: System.AggregateException
      description: "\n<p>The <xref href=\"System.AggregateException\" data-throw-if-not-resolved=\"false\"></xref> that caused the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> to end prematurely.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.Tasks.Task.Factory
  commentId: P:System.Threading.Tasks.Task.Factory
  id: Factory
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Factory
  nameWithType: Task.Factory
  fullName: System.Threading.Tasks.Task.Factory
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Factory
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 1620
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Provides access to factory methods for creating and configuring <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref> instances.</p>\n"
  remarks: "\n<p>This property returns a default instance of the <xref href=\"System.Threading.Tasks.TaskFactory\" data-throw-if-not-resolved=\"false\"></xref> class that is identical to the one created by calling the parameterless <xref href=\"System.Threading.Tasks.TaskFactory.#ctor\" data-throw-if-not-resolved=\"false\"></xref> constructor. It has the following property values: </p>\n<p>Property</p>\n<p>Value</p>\n<table><tbody><tr><td>\n<p>\n<xref href=\"System.Threading.Tasks.TaskFactory.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td><td>\n<p>\n<xref href=\"System.Threading.CancellationToken.None\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td></tr><tr><td>\n<p>\n<xref href=\"System.Threading.Tasks.TaskFactory.ContinuationOptions\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td><td>\n<p>\n<xref href=\"System.Threading.Tasks.TaskContinuationOptions.None\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td></tr><tr><td>\n<p>\n<xref href=\"System.Threading.Tasks.TaskFactory.CreationOptions\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td><td>\n<p>\n<xref href=\"System.Threading.Tasks.TaskCreationOptions.None\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td></tr><tr><td>\n<p>\n<xref href=\"System.Threading.Tasks.TaskFactory.Scheduler\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td><td>\n<p>\n<strong>null</strong>, or <xref href=\"System.Threading.Tasks.TaskScheduler.Current\" data-throw-if-not-resolved=\"false\"></xref></p>\n</td></tr></tbody></table>\n<p>The most common use of this property is to create and start a new task in a single call to the <xref href=\"System.Threading.Tasks.TaskFactory.StartNew(System.Action)\" data-throw-if-not-resolved=\"false\"></xref> method. </p>\n<p>Starting with the .NET Framework 4.5, the <xref href=\"System.Threading.Tasks.Task.Run(System.Action)\" data-throw-if-not-resolved=\"false\"></xref> method provides the easiest way to create a <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> object with default configuration values. </p>\n<p>The following example uses the static <xref href=\"System.Threading.Tasks.Task.Factory\" data-throw-if-not-resolved=\"false\"></xref> property to make two calls to the <xref href=\"System.Threading.Tasks.TaskFactory.StartNew(System.Action)\" data-throw-if-not-resolved=\"false\"></xref> method. The first populates an array with the names of files in the user's MyDocuments directory, while the second populates an array with the names of subdirectories of the user's MyDocuments directory. It then calls the <xref href=\"System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]})\" data-throw-if-not-resolved=\"false\"></xref> method, which displays information about the number of files and directories in the two arrays after the first two tasks have completed execution.</p>System.Threading.Tasks.Task.Factory#1"
  syntax:
    content: public static TaskFactory Factory { get; }
    content.vb: Public Shared ReadOnly Property Factory As TaskFactory
    parameters: []
    return:
      type: System.Threading.Tasks.TaskFactory
      description: "\n<p>A factory object that can create a variety of <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref> objects. </p>\n"
  seealso:
  - type: System.Threading.Tasks.TaskFactory
    commentId: T:System.Threading.Tasks.TaskFactory
  modifiers.csharp:
  - public
  - static
  - get
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Threading.Tasks.Task.Id
  commentId: P:System.Threading.Tasks.Task.Id
  id: Id
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Id
  nameWithType: Task.Id
  fullName: System.Threading.Tasks.Task.Id
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Id
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 1315
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Gets an ID for this <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instance.</p>\n"
  remarks: "\n<p>Task IDs are assigned on-demand and do not necessarily represent the order in which task instances are created. Note that although collisions are very rare, task identifiers are not guaranteed to be unique. </p>\n<p>To get the task ID of the currently executing task from within code that that task is executing, use the <xref href=\"System.Threading.Tasks.Task.CurrentId\" data-throw-if-not-resolved=\"false\"></xref> property. </p>\n"
  syntax:
    content: public int Id { get; }
    content.vb: Public ReadOnly Property Id As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>The identifier that is assigned by the system to this <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instance. </p>\n"
  seealso:
  - type: System.Threading.Tasks.Task.CurrentId
    commentId: P:System.Threading.Tasks.Task.CurrentId
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.Tasks.Task.IsCanceled
  commentId: P:System.Threading.Tasks.Task.IsCanceled
  id: IsCanceled
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: IsCanceled
  nameWithType: Task.IsCanceled
  fullName: System.Threading.Tasks.Task.IsCanceled
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: IsCanceled
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 1449
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Gets whether this <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instance has completed execution due to being canceled.</p>\n"
  remarks: "\n<p>A <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> will complete in the <xref href=\"System.Threading.Tasks.TaskStatus.Canceled\" data-throw-if-not-resolved=\"false\"></xref> state under any of the following conditions: </p>\n<ul><li>\n<p>Its <xref href=\"System.Threading.Tasks.TaskFactory.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> was marked for cancellation before the task started executing, </p>\n</li><li>\n<p>The task acknowledged the cancellation request on its already signaled <xref href=\"System.Threading.Tasks.TaskFactory.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> by throwing an <xref href=\"System.OperationCanceledException\" data-throw-if-not-resolved=\"false\"></xref> that bears the same <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n</li><li>\n<p>The task acknowledged the cancellation request on its already signaled <xref href=\"System.Threading.Tasks.TaskFactory.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> by calling the <xref href=\"System.Threading.CancellationToken.ThrowIfCancellationRequested\" data-throw-if-not-resolved=\"false\"></xref> method on the <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n</li></ul>\n<p>Retrieving the value of the <xref href=\"System.Threading.Tasks.Task.IsCanceled\" data-throw-if-not-resolved=\"false\"></xref> property does not block the calling thread until the task has completed. </p>\n"
  syntax:
    content: public bool IsCanceled { get; }
    content.vb: Public ReadOnly Property IsCanceled As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the task has completed due to being canceled; otherwise <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.Tasks.Task.IsCompleted
  commentId: P:System.Threading.Tasks.Task.IsCompleted
  id: IsCompleted
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: IsCompleted
  nameWithType: Task.IsCompleted
  fullName: System.Threading.Tasks.Task.IsCompleted
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: IsCompleted
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 1525
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Gets whether this <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> has completed.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Threading.Tasks.Task.IsCompleted\" data-throw-if-not-resolved=\"false\"></xref> will return <strong>true</strong> when the task is in one of the three final states: <xref href=\"System.Threading.Tasks.TaskStatus.RanToCompletion\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Threading.Tasks.TaskStatus.Faulted\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Threading.Tasks.TaskStatus.Canceled\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>Retrieving the value of the <xref href=\"System.Threading.Tasks.Task.IsCompleted\" data-throw-if-not-resolved=\"false\"></xref> property does not block the calling thread until the task has completed. </p>\n"
  syntax:
    content: public bool IsCompleted { get; }
    content.vb: Public ReadOnly Property IsCompleted As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the task has completed; otherwise <strong>false</strong>.</p>\n"
  implements:
  - System.IAsyncResult.IsCompleted
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.Tasks.Task.IsFaulted
  commentId: P:System.Threading.Tasks.Task.IsFaulted
  id: IsFaulted
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: IsFaulted
  nameWithType: Task.IsFaulted
  fullName: System.Threading.Tasks.Task.IsFaulted
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: IsFaulted
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 1718
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Gets whether the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completed due to an unhandled exception.</p>\n"
  remarks: "\n<p>If <xref href=\"System.Threading.Tasks.Task.IsFaulted\" data-throw-if-not-resolved=\"false\"></xref> is <strong>true</strong>, the task's <xref href=\"System.Threading.Tasks.Task.Status\" data-throw-if-not-resolved=\"false\"></xref> is equal to <xref href=\"System.Threading.Tasks.TaskStatus.Faulted\" data-throw-if-not-resolved=\"false\"></xref>, and its <xref href=\"System.Threading.Tasks.Task.Exception\" data-throw-if-not-resolved=\"false\"></xref> property will be non-null.</p>\n<p>Retrieving the value of the <xref href=\"System.Threading.Tasks.Task.IsFaulted\" data-throw-if-not-resolved=\"false\"></xref> property does not block the calling thread until the task has completed. </p>\n"
  syntax:
    content: public bool IsFaulted { get; }
    content.vb: Public ReadOnly Property IsFaulted As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the task has thrown an unhandled exception; otherwise <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.Tasks.Task.Status
  commentId: P:System.Threading.Tasks.Task.Status
  id: Status
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Status
  nameWithType: Task.Status
  fullName: System.Threading.Tasks.Task.Status
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Status
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 1414
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Gets the <xref href=\"System.Threading.Tasks.TaskStatus\" data-throw-if-not-resolved=\"false\"></xref> of this task.</p>\n"
  remarks: "\n<p>Retrieving the value of the <xref href=\"System.Threading.Tasks.Task.Status\" data-throw-if-not-resolved=\"false\"></xref> property does not block the calling thread until the task has completed. </p>\n<p>For more information and an example, see Chaining Tasks by Using Continuation Tasks and How to: Cancel a Task and Its Children.</p>\n"
  syntax:
    content: public TaskStatus Status { get; }
    content.vb: Public ReadOnly Property Status As TaskStatus
    parameters: []
    return:
      type: System.Threading.Tasks.TaskStatus
      description: "\n<p>The current <xref href=\"System.Threading.Tasks.TaskStatus\" data-throw-if-not-resolved=\"false\"></xref> of this task instance.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle
  commentId: P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle
  id: System#IAsyncResult#AsyncWaitHandle
  isEii: true
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: IAsyncResult.AsyncWaitHandle
  nameWithType: Task.IAsyncResult.AsyncWaitHandle
  fullName: System.Threading.Tasks.Task.System.IAsyncResult.AsyncWaitHandle
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: System.IAsyncResult.AsyncWaitHandle
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 1568
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Gets a <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> that can be used to wait for the task to complete.</p>\n"
  remarks: "\n<p>Using the wait functionality provided by <xref href=\"System.Threading.Tasks.Task.Wait\" data-throw-if-not-resolved=\"false\"></xref> is preferable to using <xref href=\"System.IAsyncResult.AsyncWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> for similar functionality. For more information, see the \"Waiting on Tasks\" section in Task Parallelism (Task Parallel Library) and Using TPL with Other Asynchronous Patterns.</p>\n"
  syntax:
    content: WaitHandle IAsyncResult.AsyncWaitHandle { get; }
    content.vb: ReadOnly WriteOnly Property System.IAsyncResult.AsyncWaitHandle As WaitHandle Implements IAsyncResult.AsyncWaitHandle
    parameters: []
    return:
      type: System.Threading.WaitHandle
      description: "\n<p>A <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> that can be used to wait for the task to complete.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> has been disposed.</p>\n"
  implements:
  - System.IAsyncResult.AsyncWaitHandle
  nameWithType.vb: Task.System.IAsyncResult.AsyncWaitHandle
  modifiers.csharp:
  - get
  modifiers.vb:
  - ReadOnly
  name.vb: System.IAsyncResult.AsyncWaitHandle
- uid: System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously
  commentId: P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously
  id: System#IAsyncResult#CompletedSynchronously
  isEii: true
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: IAsyncResult.CompletedSynchronously
  nameWithType: Task.IAsyncResult.CompletedSynchronously
  fullName: System.Threading.Tasks.Task.System.IAsyncResult.CompletedSynchronously
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: System.IAsyncResult.CompletedSynchronously
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 1596
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Gets an indication of whether the operation completed synchronously.</p>\n"
  syntax:
    content: bool IAsyncResult.CompletedSynchronously { get; }
    content.vb: ReadOnly WriteOnly Property System.IAsyncResult.CompletedSynchronously As Boolean Implements IAsyncResult.CompletedSynchronously
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the operation completed synchronously; otherwise, <strong>false</strong>.</p>\n"
  implements:
  - System.IAsyncResult.CompletedSynchronously
  nameWithType.vb: Task.System.IAsyncResult.CompletedSynchronously
  modifiers.csharp:
  - get
  modifiers.vb:
  - ReadOnly
  name.vb: System.IAsyncResult.CompletedSynchronously
- uid: System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)
  commentId: M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)
  id: ConfigureAwait(System.Boolean)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: ConfigureAwait(Boolean)
  nameWithType: Task.ConfigureAwait(Boolean)
  fullName: System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ConfigureAwait
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 2914
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Configures an awaiter used to await this <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  syntax:
    content: public ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext)
    content.vb: Public Function ConfigureAwait(continueOnCapturedContext As Boolean) As ConfiguredTaskAwaitable
    parameters:
    - id: continueOnCapturedContext
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> to attempt to marshal the continuation back to the original context captured; otherwise, <strong>false</strong>.</p>\n"
    return:
      type: System.Runtime.CompilerServices.ConfiguredTaskAwaitable
      description: "\n<p>An object used to await this task.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)
  commentId: M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)
  id: ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: ContinueWith(Action<Task, Object>, Object)
  nameWithType: Task.ContinueWith(Action<Task, Object>, Object)
  fullName: System.Threading.Tasks.Task.ContinueWith(System.Action<System.Threading.Tasks.Task, System.Object>, System.Object)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ContinueWith
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 3928
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a continuation that receives caller-supplied state information and executes when the target <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes. </p>\n"
  remarks: "\n<p>The returned <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting early due to cancellation. </p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task ContinueWith(Action<Task, object> continuationAction, object state)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Function ContinueWith(continuationAction As Action(Of Task, Object), state As Object) As Task
    parameters:
    - id: continuationAction
      type: System.Action{System.Threading.Tasks.Task,System.Object}
      description: "\n<p>An action to run when the task completes. When run, the delegate is passed the completed task and a caller-supplied state object as arguments. </p>\n"
    - id: state
      type: System.Object
      description: "\n<p>An object representing data to be used by the continuation action. </p>\n"
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>A new continuation task. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>continuationAction</em> argument is <strong>null</strong>.</p>\n"
  nameWithType.vb: Task.ContinueWith(Action(Of Task, Object), Object)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.Tasks.Task.ContinueWith(System.Action(Of System.Threading.Tasks.Task, System.Object), System.Object)
  name.vb: ContinueWith(Action(Of Task, Object), Object)
- uid: System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)
  commentId: M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)
  id: ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: ContinueWith(Action<Task, Object>, Object, CancellationToken)
  nameWithType: Task.ContinueWith(Action<Task, Object>, Object, CancellationToken)
  fullName: System.Threading.Tasks.Task.ContinueWith(System.Action<System.Threading.Tasks.Task, System.Object>, System.Object, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ContinueWith
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 3956
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a continuation that receives caller-supplied state information and a cancellation token and that executes asynchronously when the target <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes.</p>\n"
  remarks: "\n<p>The returned <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task ContinueWith(Action<Task, object> continuationAction, object state, CancellationToken cancellationToken)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Function ContinueWith(continuationAction As Action(Of Task, Object), state As Object, cancellationToken As CancellationToken) As Task
    parameters:
    - id: continuationAction
      type: System.Action{System.Threading.Tasks.Task,System.Object}
      description: "\n<p>An action to run when the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes. When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</p>\n"
    - id: state
      type: System.Object
      description: "\n<p>An object representing data to be used by the continuation action.</p>\n"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\n<p>The <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> that will be assigned to the new continuation task.</p>\n"
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>A new continuation <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>continuationAction</em> argument is <strong>null</strong>.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The provided <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> has already been disposed.</p>\n"
  nameWithType.vb: Task.ContinueWith(Action(Of Task, Object), Object, CancellationToken)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.Tasks.Task.ContinueWith(System.Action(Of System.Threading.Tasks.Task, System.Object), System.Object, System.Threading.CancellationToken)
  name.vb: ContinueWith(Action(Of Task, Object), Object, CancellationToken)
- uid: System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)
  commentId: M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)
  id: ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: ContinueWith(Action<Task, Object>, Object, CancellationToken, TaskContinuationOptions, TaskScheduler)
  nameWithType: Task.ContinueWith(Action<Task, Object>, Object, CancellationToken, TaskContinuationOptions, TaskScheduler)
  fullName: System.Threading.Tasks.Task.ContinueWith(System.Action<System.Threading.Tasks.Task, System.Object>, System.Object, System.Threading.CancellationToken, System.Threading.Tasks.TaskContinuationOptions, System.Threading.Tasks.TaskScheduler)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ContinueWith
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 4068
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a continuation that receives caller-supplied state information and a cancellation token and that executes when the target <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes. The continuation executes based on a set of specified conditions and uses a specified scheduler. </p>\n"
  remarks: "\n<p>The returned <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> will not be scheduled for execution until the current task has  completed. If the criteria specified through the <em>continuationOptions</em> parameter  are not met, the continuation task will be canceled instead of scheduled.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task ContinueWith(Action<Task, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Function ContinueWith(continuationAction As Action(Of Task, Object), state As Object, cancellationToken As CancellationToken, continuationOptions As TaskContinuationOptions, scheduler As TaskScheduler) As Task
    parameters:
    - id: continuationAction
      type: System.Action{System.Threading.Tasks.Task,System.Object}
      description: "\n<p>An action to run when the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes. When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</p>\n"
    - id: state
      type: System.Object
      description: "\n<p>An object representing data to be used by the continuation action.</p>\n"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\n<p>The <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> that will be assigned to the new continuation task.</p>\n"
    - id: continuationOptions
      type: System.Threading.Tasks.TaskContinuationOptions
      description: "\n<p>Options for when the continuation is scheduled and how it behaves. This includes criteria, such as <xref href=\"System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled\" data-throw-if-not-resolved=\"false\"></xref>, as well as execution options, such as <xref href=\"System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    - id: scheduler
      type: System.Threading.Tasks.TaskScheduler
      description: "\n<p>The <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> to associate with the continuation task and to use for its  execution.</p>\n"
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>A new continuation <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>continuationAction</em> argument is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The <em>continuationOptions</em> argument specifies an invalid value for <xref href=\"System.Threading.Tasks.TaskContinuationOptions\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>scheduler</em> argument is <strong>null</strong>.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The provided <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> has already been disposed.</p>\n"
  nameWithType.vb: Task.ContinueWith(Action(Of Task, Object), Object, CancellationToken, TaskContinuationOptions, TaskScheduler)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.Tasks.Task.ContinueWith(System.Action(Of System.Threading.Tasks.Task, System.Object), System.Object, System.Threading.CancellationToken, System.Threading.Tasks.TaskContinuationOptions, System.Threading.Tasks.TaskScheduler)
  name.vb: ContinueWith(Action(Of Task, Object), Object, CancellationToken, TaskContinuationOptions, TaskScheduler)
- uid: System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)
  commentId: M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)
  id: ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: ContinueWith(Action<Task, Object>, Object, TaskContinuationOptions)
  nameWithType: Task.ContinueWith(Action<Task, Object>, Object, TaskContinuationOptions)
  fullName: System.Threading.Tasks.Task.ContinueWith(System.Action<System.Threading.Tasks.Task, System.Object>, System.Object, System.Threading.Tasks.TaskContinuationOptions)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ContinueWith
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 4022
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a continuation that receives caller-supplied state information and executes when the target <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes. The continuation executes based on a set of specified conditions. </p>\n"
  remarks: "\n<p>The returned <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> will not be scheduled for execution until the current task has completed. If the continuation criteria specified through the <em>continuationOptions</em> parameter are not met, the continuation task will be canceled instead of scheduled.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task ContinueWith(Action<Task, object> continuationAction, object state, TaskContinuationOptions continuationOptions)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Function ContinueWith(continuationAction As Action(Of Task, Object), state As Object, continuationOptions As TaskContinuationOptions) As Task
    parameters:
    - id: continuationAction
      type: System.Action{System.Threading.Tasks.Task,System.Object}
      description: "\n<p>An action to run when the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes. When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</p>\n"
    - id: state
      type: System.Object
      description: "\n<p>An object representing data to be used by the continuation action.</p>\n"
    - id: continuationOptions
      type: System.Threading.Tasks.TaskContinuationOptions
      description: "\n<p>Options for when the continuation is scheduled and how it behaves. This includes criteria, such as <xref href=\"System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled\" data-throw-if-not-resolved=\"false\"></xref>, as well as execution options, such as <xref href=\"System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>A new continuation <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>continuationAction</em> argument is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The <em>continuationOptions</em> argument specifies an invalid value for <xref href=\"System.Threading.Tasks.TaskContinuationOptions\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  nameWithType.vb: Task.ContinueWith(Action(Of Task, Object), Object, TaskContinuationOptions)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.Tasks.Task.ContinueWith(System.Action(Of System.Threading.Tasks.Task, System.Object), System.Object, System.Threading.Tasks.TaskContinuationOptions)
  name.vb: ContinueWith(Action(Of Task, Object), Object, TaskContinuationOptions)
- uid: System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)
  commentId: M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)
  id: ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: ContinueWith(Action<Task, Object>, Object, TaskScheduler)
  nameWithType: Task.ContinueWith(Action<Task, Object>, Object, TaskScheduler)
  fullName: System.Threading.Tasks.Task.ContinueWith(System.Action<System.Threading.Tasks.Task, System.Object>, System.Object, System.Threading.Tasks.TaskScheduler)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ContinueWith
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 3986
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a continuation that receives caller-supplied state information and executes asynchronously when the target <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes. The continuation uses a specified scheduler. </p>\n"
  remarks: "\n<p>The returned <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task ContinueWith(Action<Task, object> continuationAction, object state, TaskScheduler scheduler)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Function ContinueWith(continuationAction As Action(Of Task, Object), state As Object, scheduler As TaskScheduler) As Task
    parameters:
    - id: continuationAction
      type: System.Action{System.Threading.Tasks.Task,System.Object}
      description: "\n<p>An action to run when the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes.  When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</p>\n"
    - id: state
      type: System.Object
      description: "\n<p>An object representing data to be used by the continuation action.</p>\n"
    - id: scheduler
      type: System.Threading.Tasks.TaskScheduler
      description: "\n<p>The <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> to associate with the continuation task and to use for its execution.</p>\n"
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>A new continuation <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>continuationAction</em> argument is <strong>null</strong>.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>scheduler</em> argument is <strong>null</strong>.</p>\n"
  nameWithType.vb: Task.ContinueWith(Action(Of Task, Object), Object, TaskScheduler)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.Tasks.Task.ContinueWith(System.Action(Of System.Threading.Tasks.Task, System.Object), System.Object, System.Threading.Tasks.TaskScheduler)
  name.vb: ContinueWith(Action(Of Task, Object), Object, TaskScheduler)
- uid: System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})
  commentId: M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})
  id: ContinueWith(System.Action{System.Threading.Tasks.Task})
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: ContinueWith(Action<Task>)
  nameWithType: Task.ContinueWith(Action<Task>)
  fullName: System.Threading.Tasks.Task.ContinueWith(System.Action<System.Threading.Tasks.Task>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ContinueWith
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 3730
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a continuation that executes asynchronously when the target <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes.</p>\n"
  remarks: "\n<p>The returned <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task ContinueWith(Action<Task> continuationAction)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Function ContinueWith(continuationAction As Action(Of Task)) As Task
    parameters:
    - id: continuationAction
      type: System.Action{System.Threading.Tasks.Task}
      description: "\n<p>An action to run when the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes. When run, the delegate will be passed the completed task as an argument.</p>\n"
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>A new continuation <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>continuationAction</em> argument is <strong>null</strong>.</p>\n"
  nameWithType.vb: Task.ContinueWith(Action(Of Task))
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.Tasks.Task.ContinueWith(System.Action(Of System.Threading.Tasks.Task))
  name.vb: ContinueWith(Action(Of Task))
- uid: System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)
  commentId: M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)
  id: ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: ContinueWith(Action<Task>, CancellationToken)
  nameWithType: Task.ContinueWith(Action<Task>, CancellationToken)
  fullName: System.Threading.Tasks.Task.ContinueWith(System.Action<System.Threading.Tasks.Task>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ContinueWith
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 3757
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a continuation that receives a cancellation token and executes asynchronously when the target <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes.</p>\n"
  remarks: "\n<p>The returned <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task ContinueWith(Action<Task> continuationAction, CancellationToken cancellationToken)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Function ContinueWith(continuationAction As Action(Of Task), cancellationToken As CancellationToken) As Task
    parameters:
    - id: continuationAction
      type: System.Action{System.Threading.Tasks.Task}
      description: "\n<p>An action to run when the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes. When run, the delegate will be passed the completed task as an argument.</p>\n"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\n<p>The <xref href=\"System.Threading.Tasks.TaskFactory.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> that will be assigned to the new continuation task.</p>\n"
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>A new continuation <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> that created the token has already been disposed. </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>continuationAction</em> argument is null.</p>\n"
  nameWithType.vb: Task.ContinueWith(Action(Of Task), CancellationToken)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.Tasks.Task.ContinueWith(System.Action(Of System.Threading.Tasks.Task), System.Threading.CancellationToken)
  name.vb: ContinueWith(Action(Of Task), CancellationToken)
- uid: System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)
  commentId: M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)
  id: ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: ContinueWith(Action<Task>, CancellationToken, TaskContinuationOptions, TaskScheduler)
  nameWithType: Task.ContinueWith(Action<Task>, CancellationToken, TaskContinuationOptions, TaskScheduler)
  fullName: System.Threading.Tasks.Task.ContinueWith(System.Action<System.Threading.Tasks.Task>, System.Threading.CancellationToken, System.Threading.Tasks.TaskContinuationOptions, System.Threading.Tasks.TaskScheduler)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ContinueWith
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 3866
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a continuation that executes when the target task competes according to the specified <xref href=\"System.Threading.Tasks.TaskContinuationOptions\" data-throw-if-not-resolved=\"false\"></xref>. The continuation receives a cancellation token and uses a specified scheduler. </p>\n"
  remarks: "\n<p>The returned <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> will not be scheduled for execution until the current task has completed. If the criteria specified through the <em>continuationOptions</em> parameter are not met, the continuation task will be canceled instead of scheduled.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task ContinueWith(Action<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Function ContinueWith(continuationAction As Action(Of Task), cancellationToken As CancellationToken, continuationOptions As TaskContinuationOptions, scheduler As TaskScheduler) As Task
    parameters:
    - id: continuationAction
      type: System.Action{System.Threading.Tasks.Task}
      description: "\n<p>An action to run according to the specified <em>continuationOptions</em>. When run, the delegate will be passed the completed task as an argument.</p>\n"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\n<p>The <xref href=\"System.Threading.Tasks.TaskFactory.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> that will be assigned to the new continuation task.</p>\n"
    - id: continuationOptions
      type: System.Threading.Tasks.TaskContinuationOptions
      description: "\n<p>Options for when the continuation is scheduled and how it behaves. This includes criteria, such as <xref href=\"System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled\" data-throw-if-not-resolved=\"false\"></xref>, as well as execution options, such as <xref href=\"System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    - id: scheduler
      type: System.Threading.Tasks.TaskScheduler
      description: "\n<p>The <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> to associate with the continuation task and to use for its execution.</p>\n"
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>A new continuation <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> that created the token has already been disposed.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>continuationAction</em> argument is null.</p>\n<p>-or-</p>\n<p>The <em>scheduler</em> argument is null.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The <em>continuationOptions</em> argument specifies an invalid value for <xref href=\"System.Threading.Tasks.TaskContinuationOptions\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  nameWithType.vb: Task.ContinueWith(Action(Of Task), CancellationToken, TaskContinuationOptions, TaskScheduler)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.Tasks.Task.ContinueWith(System.Action(Of System.Threading.Tasks.Task), System.Threading.CancellationToken, System.Threading.Tasks.TaskContinuationOptions, System.Threading.Tasks.TaskScheduler)
  name.vb: ContinueWith(Action(Of Task), CancellationToken, TaskContinuationOptions, TaskScheduler)
- uid: System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)
  commentId: M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)
  id: ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: ContinueWith(Action<Task>, TaskContinuationOptions)
  nameWithType: Task.ContinueWith(Action<Task>, TaskContinuationOptions)
  fullName: System.Threading.Tasks.Task.ContinueWith(System.Action<System.Threading.Tasks.Task>, System.Threading.Tasks.TaskContinuationOptions)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ContinueWith
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 3821
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a continuation that executes when the target task completes according to the specified <xref href=\"System.Threading.Tasks.TaskContinuationOptions\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>The returned <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> will not be scheduled for execution until the current task has completed. If the continuation criteria specified through the <em>continuationOptions</em> parameter are not met, the continuation task will be canceled instead of scheduled.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task ContinueWith(Action<Task> continuationAction, TaskContinuationOptions continuationOptions)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Function ContinueWith(continuationAction As Action(Of Task), continuationOptions As TaskContinuationOptions) As Task
    parameters:
    - id: continuationAction
      type: System.Action{System.Threading.Tasks.Task}
      description: "\n<p>An action to run according to the specified <em>continuationOptions</em>. When run, the delegate will be passed the completed task as an argument.</p>\n"
    - id: continuationOptions
      type: System.Threading.Tasks.TaskContinuationOptions
      description: "\n<p>Options for when the continuation is scheduled and how it behaves. This includes criteria, such as <xref href=\"System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled\" data-throw-if-not-resolved=\"false\"></xref>, as well as execution options, such as <xref href=\"System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>A new continuation <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>continuationAction</em> argument is null.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The <em>continuationOptions</em> argument specifies an invalid value for <xref href=\"System.Threading.Tasks.TaskContinuationOptions\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  nameWithType.vb: Task.ContinueWith(Action(Of Task), TaskContinuationOptions)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.Tasks.Task.ContinueWith(System.Action(Of System.Threading.Tasks.Task), System.Threading.Tasks.TaskContinuationOptions)
  name.vb: ContinueWith(Action(Of Task), TaskContinuationOptions)
- uid: System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)
  commentId: M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)
  id: ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: ContinueWith(Action<Task>, TaskScheduler)
  nameWithType: Task.ContinueWith(Action<Task>, TaskScheduler)
  fullName: System.Threading.Tasks.Task.ContinueWith(System.Action<System.Threading.Tasks.Task>, System.Threading.Tasks.TaskScheduler)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ContinueWith
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 3786
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a continuation that executes asynchronously when the target <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes. The continuation uses a specified scheduler. </p>\n"
  remarks: "\n<p>The returned <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task ContinueWith(Action<Task> continuationAction, TaskScheduler scheduler)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Function ContinueWith(continuationAction As Action(Of Task), scheduler As TaskScheduler) As Task
    parameters:
    - id: continuationAction
      type: System.Action{System.Threading.Tasks.Task}
      description: "\n<p>An action to run when the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes. When run, the delegate will be passed the completed task as an argument.</p>\n"
    - id: scheduler
      type: System.Threading.Tasks.TaskScheduler
      description: "\n<p>The <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> to associate with the continuation task and to use for its execution.</p>\n"
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>A new continuation <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> has been disposed.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>continuationAction</em> argument is <strong>null</strong>. </p>\n<p>-or-</p>\n<p>The <em>scheduler</em> argument is null.</p>\n"
  nameWithType.vb: Task.ContinueWith(Action(Of Task), TaskScheduler)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.Tasks.Task.ContinueWith(System.Action(Of System.Threading.Tasks.Task), System.Threading.Tasks.TaskScheduler)
  name.vb: ContinueWith(Action(Of Task), TaskScheduler)
- uid: System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})
  commentId: M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})
  id: ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: ContinueWith<TResult>(Func<Task, TResult>)
  nameWithType: Task.ContinueWith<TResult>(Func<Task, TResult>)
  fullName: System.Threading.Tasks.Task.ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, TResult>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ContinueWith
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 4133
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a continuation that executes asynchronously when the target <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref> completes and returns a value. </p>\n"
  remarks: "\n<p>The returned <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task<TResult> ContinueWith<TResult>(Func<Task, TResult> continuationFunction)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Function ContinueWith(Of TResult)(continuationFunction As Func(Of Task, TResult)) As Task(Of TResult)
    parameters:
    - id: continuationFunction
      type: System.Func{System.Threading.Tasks.Task,{TResult}}
      description: "\n<p>A function to run when the <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref>  completes. When run, the delegate will be passed the completed task as an argument.</p>\n"
    typeParameters:
    - id: TResult
      description: "\n<p> The type of the result produced by the continuation.</p>\n<p></p>\n"
    return:
      type: System.Threading.Tasks.Task{{TResult}}
      description: "\n<p>A new continuation task. </p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> has been disposed.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>continuationFunction</em> argument is null.</p>\n"
  nameWithType.vb: Task.ContinueWith(Of TResult)(Func(Of Task, TResult))
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.Tasks.Task.ContinueWith(Of TResult)(System.Func(Of System.Threading.Tasks.Task, TResult))
  name.vb: ContinueWith(Of TResult)(Func(Of Task, TResult))
- uid: System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)
  commentId: M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)
  id: ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: ContinueWith<TResult>(Func<Task, TResult>, CancellationToken)
  nameWithType: Task.ContinueWith<TResult>(Func<Task, TResult>, CancellationToken)
  fullName: System.Threading.Tasks.Task.ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, TResult>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ContinueWith
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 4165
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a continuation that executes asynchronously when the target <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes and returns a value. The continuation receives a cancellation token. </p>\n"
  remarks: "\n<p>The returned <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task<TResult> ContinueWith<TResult>(Func<Task, TResult> continuationFunction, CancellationToken cancellationToken)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Function ContinueWith(Of TResult)(continuationFunction As Func(Of Task, TResult), cancellationToken As CancellationToken) As Task(Of TResult)
    parameters:
    - id: continuationFunction
      type: System.Func{System.Threading.Tasks.Task,{TResult}}
      description: "\n<p>A function to run when the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes. When run, the delegate will be passed the completed task as an argument.</p>\n"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\n<p>The <xref href=\"System.Threading.Tasks.TaskFactory.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> that will be assigned to the new continuation task.</p>\n"
    typeParameters:
    - id: TResult
      description: "\n<p> The type of the result produced by the continuation.</p>\n<p></p>\n"
    return:
      type: System.Threading.Tasks.Task{{TResult}}
      description: "\n<p>A new continuation <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> has been disposed.</p>\n<p>-or-</p>\n<p>The <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> that created the token has already been disposed.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>continuationFunction</em> argument is null.</p>\n"
  nameWithType.vb: Task.ContinueWith(Of TResult)(Func(Of Task, TResult), CancellationToken)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.Tasks.Task.ContinueWith(Of TResult)(System.Func(Of System.Threading.Tasks.Task, TResult), System.Threading.CancellationToken)
  name.vb: ContinueWith(Of TResult)(Func(Of Task, TResult), CancellationToken)
- uid: System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)
  commentId: M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)
  id: ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: ContinueWith<TResult>(Func<Task, TResult>, CancellationToken, TaskContinuationOptions, TaskScheduler)
  nameWithType: Task.ContinueWith<TResult>(Func<Task, TResult>, CancellationToken, TaskContinuationOptions, TaskScheduler)
  fullName: System.Threading.Tasks.Task.ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, TResult>, System.Threading.CancellationToken, System.Threading.Tasks.TaskContinuationOptions, System.Threading.Tasks.TaskScheduler)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ContinueWith
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 4283
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a continuation that executes according to the specified continuation options and returns a value. The continuation is passed a cancellation token and uses a specified scheduler. </p>\n"
  remarks: "\n<p>The returned <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref> will not be scheduled for execution until the current task has completed. If the criteria specified through the <em>continuationOptions</em> parameter are not met, the continuation task will be canceled instead of scheduled.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task<TResult> ContinueWith<TResult>(Func<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Function ContinueWith(Of TResult)(continuationFunction As Func(Of Task, TResult), cancellationToken As CancellationToken, continuationOptions As TaskContinuationOptions, scheduler As TaskScheduler) As Task(Of TResult)
    parameters:
    - id: continuationFunction
      type: System.Func{System.Threading.Tasks.Task,{TResult}}
      description: "\n<p>A function to run according to the specified <em>continuationOptions.</em> When run, the delegate will be passed the completed task as an argument.</p>\n"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\n<p>The <xref href=\"System.Threading.Tasks.TaskFactory.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> that will be assigned to the new continuation task.</p>\n"
    - id: continuationOptions
      type: System.Threading.Tasks.TaskContinuationOptions
      description: "\n<p>Options for when the continuation is scheduled and how it behaves. This includes criteria, such as <xref href=\"System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled\" data-throw-if-not-resolved=\"false\"></xref>, as well as execution options, such as <xref href=\"System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    - id: scheduler
      type: System.Threading.Tasks.TaskScheduler
      description: "\n<p>The <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> to associate with the continuation task and to use for its execution.</p>\n"
    typeParameters:
    - id: TResult
      description: "\n<p> The type of the result produced by the continuation.</p>\n<p></p>\n"
    return:
      type: System.Threading.Tasks.Task{{TResult}}
      description: "\n<p>A new continuation <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> has been disposed.</p>\n<p>-or-</p>\n<p>The <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> that created the token has already been disposed.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>continuationFunction</em> argument is null.</p>\n<p>-or-</p>\n<p>The <em>scheduler</em> argument is null.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The <em>continuationOptions</em> argument specifies an invalid value for <xref href=\"System.Threading.Tasks.TaskContinuationOptions\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  nameWithType.vb: Task.ContinueWith(Of TResult)(Func(Of Task, TResult), CancellationToken, TaskContinuationOptions, TaskScheduler)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.Tasks.Task.ContinueWith(Of TResult)(System.Func(Of System.Threading.Tasks.Task, TResult), System.Threading.CancellationToken, System.Threading.Tasks.TaskContinuationOptions, System.Threading.Tasks.TaskScheduler)
  name.vb: ContinueWith(Of TResult)(Func(Of Task, TResult), CancellationToken, TaskContinuationOptions, TaskScheduler)
- uid: System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)
  commentId: M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)
  id: ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: ContinueWith<TResult>(Func<Task, TResult>, TaskContinuationOptions)
  nameWithType: Task.ContinueWith<TResult>(Func<Task, TResult>, TaskContinuationOptions)
  fullName: System.Threading.Tasks.Task.ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, TResult>, System.Threading.Tasks.TaskContinuationOptions)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ContinueWith
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 4235
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a continuation that executes according to the specified continuation options and returns a value. </p>\n"
  remarks: "\n<p>The returned <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref> will not be scheduled for execution until the current task has completed. If the continuation criteria specified through the <em>continuationOptions</em> parameter are not met, the continuation task will be canceled instead of scheduled.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task<TResult> ContinueWith<TResult>(Func<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Function ContinueWith(Of TResult)(continuationFunction As Func(Of Task, TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)
    parameters:
    - id: continuationFunction
      type: System.Func{System.Threading.Tasks.Task,{TResult}}
      description: "\n<p>A function to run according to the condition specified in <em>continuationOptions</em>. When run, the delegate will be passed the completed task as an argument.</p>\n"
    - id: continuationOptions
      type: System.Threading.Tasks.TaskContinuationOptions
      description: "\n<p>Options for when the continuation is scheduled and how it behaves. This includes criteria, such as <xref href=\"System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled\" data-throw-if-not-resolved=\"false\"></xref>, as well as execution options, such as <xref href=\"System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    typeParameters:
    - id: TResult
      description: "\n<p> The type of the result produced by the continuation.</p>\n<p></p>\n"
    return:
      type: System.Threading.Tasks.Task{{TResult}}
      description: "\n<p>A new continuation <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> has been disposed.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>continuationFunction</em> argument is null.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The <em>continuationOptions</em> argument specifies an invalid value for <xref href=\"System.Threading.Tasks.TaskContinuationOptions\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  nameWithType.vb: Task.ContinueWith(Of TResult)(Func(Of Task, TResult), TaskContinuationOptions)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.Tasks.Task.ContinueWith(Of TResult)(System.Func(Of System.Threading.Tasks.Task, TResult), System.Threading.Tasks.TaskContinuationOptions)
  name.vb: ContinueWith(Of TResult)(Func(Of Task, TResult), TaskContinuationOptions)
- uid: System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)
  commentId: M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)
  id: ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: ContinueWith<TResult>(Func<Task, TResult>, TaskScheduler)
  nameWithType: Task.ContinueWith<TResult>(Func<Task, TResult>, TaskScheduler)
  fullName: System.Threading.Tasks.Task.ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, TResult>, System.Threading.Tasks.TaskScheduler)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ContinueWith
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 4197
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a continuation that executes asynchronously when the target <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes and returns a value. The continuation uses a specified scheduler. </p>\n"
  remarks: "\n<p>The returned <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task<TResult> ContinueWith<TResult>(Func<Task, TResult> continuationFunction, TaskScheduler scheduler)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Function ContinueWith(Of TResult)(continuationFunction As Func(Of Task, TResult), scheduler As TaskScheduler) As Task(Of TResult)
    parameters:
    - id: continuationFunction
      type: System.Func{System.Threading.Tasks.Task,{TResult}}
      description: "\n<p>A function to run when the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes. When run, the delegate will be passed the completed task as an argument.</p>\n"
    - id: scheduler
      type: System.Threading.Tasks.TaskScheduler
      description: "\n<p>The <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> to associate with the continuation task and to use for its execution.</p>\n"
    typeParameters:
    - id: TResult
      description: "\n<p> The type of the result produced by the continuation.</p>\n<p></p>\n"
    return:
      type: System.Threading.Tasks.Task{{TResult}}
      description: "\n<p>A new continuation <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> has been disposed.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>continuationFunction</em> argument is null.</p>\n<p>-or-</p>\n<p>The <em>scheduler</em> argument is null.</p>\n"
  nameWithType.vb: Task.ContinueWith(Of TResult)(Func(Of Task, TResult), TaskScheduler)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.Tasks.Task.ContinueWith(Of TResult)(System.Func(Of System.Threading.Tasks.Task, TResult), System.Threading.Tasks.TaskScheduler)
  name.vb: ContinueWith(Of TResult)(Func(Of Task, TResult), TaskScheduler)
- uid: System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)
  commentId: M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)
  id: ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: ContinueWith<TResult>(Func<Task, Object, TResult>, Object)
  nameWithType: Task.ContinueWith<TResult>(Func<Task, Object, TResult>, Object)
  fullName: System.Threading.Tasks.Task.ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, System.Object, TResult>, System.Object)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ContinueWith
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 4348
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a continuation that receives caller-supplied state information and executes asynchronously when the target <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes and returns a value. </p>\n"
  remarks: "\n<p>The returned <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task<TResult> ContinueWith<TResult>(Func<Task, object, TResult> continuationFunction, object state)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Function ContinueWith(Of TResult)(continuationFunction As Func(Of Task, Object, TResult), state As Object) As Task(Of TResult)
    parameters:
    - id: continuationFunction
      type: System.Func{System.Threading.Tasks.Task,System.Object,{TResult}}
      description: "\n<p>A function to run when the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes. When run, the delegate will be passed the completed task and the caller-supplied state object as arguments. </p>\n"
    - id: state
      type: System.Object
      description: "\n<p>An object representing data to be used by the continuation function.</p>\n"
    typeParameters:
    - id: TResult
      description: "\n<p>The type of the result produced by the continuation.</p>\n"
    return:
      type: System.Threading.Tasks.Task{{TResult}}
      description: "\n<p>A new continuation <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>continuationFunction</em> argument is <strong>null</strong>.</p>\n"
  nameWithType.vb: Task.ContinueWith(Of TResult)(Func(Of Task, Object, TResult), Object)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.Tasks.Task.ContinueWith(Of TResult)(System.Func(Of System.Threading.Tasks.Task, System.Object, TResult), System.Object)
  name.vb: ContinueWith(Of TResult)(Func(Of Task, Object, TResult), Object)
- uid: System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)
  commentId: M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)
  id: ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: ContinueWith<TResult>(Func<Task, Object, TResult>, Object, CancellationToken)
  nameWithType: Task.ContinueWith<TResult>(Func<Task, Object, TResult>, Object, CancellationToken)
  fullName: System.Threading.Tasks.Task.ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, System.Object, TResult>, System.Object, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ContinueWith
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 4381
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a continuation that executes asynchronously when the target <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes and returns a value. The continuation receives caller-supplied state information and a cancellation token. </p>\n"
  remarks: "\n<p>The returned <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task<TResult> ContinueWith<TResult>(Func<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Function ContinueWith(Of TResult)(continuationFunction As Func(Of Task, Object, TResult), state As Object, cancellationToken As CancellationToken) As Task(Of TResult)
    parameters:
    - id: continuationFunction
      type: System.Func{System.Threading.Tasks.Task,System.Object,{TResult}}
      description: "\n<p>A function to run when the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes. When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</p>\n"
    - id: state
      type: System.Object
      description: "\n<p>An object representing data to be used by the continuation function.</p>\n"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\n<p>The <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> that will be assigned to the new continuation task.</p>\n"
    typeParameters:
    - id: TResult
      description: "\n<p>The type of the result produced by the continuation.</p>\n"
    return:
      type: System.Threading.Tasks.Task{{TResult}}
      description: "\n<p>A new continuation <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>continuationFunction</em> argument is <strong>null</strong>.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The provided <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> has already been disposed.</p>\n"
  nameWithType.vb: Task.ContinueWith(Of TResult)(Func(Of Task, Object, TResult), Object, CancellationToken)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.Tasks.Task.ContinueWith(Of TResult)(System.Func(Of System.Threading.Tasks.Task, System.Object, TResult), System.Object, System.Threading.CancellationToken)
  name.vb: ContinueWith(Of TResult)(Func(Of Task, Object, TResult), Object, CancellationToken)
- uid: System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)
  commentId: M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)
  id: ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: ContinueWith<TResult>(Func<Task, Object, TResult>, Object, CancellationToken, TaskContinuationOptions, TaskScheduler)
  nameWithType: Task.ContinueWith<TResult>(Func<Task, Object, TResult>, Object, CancellationToken, TaskContinuationOptions, TaskScheduler)
  fullName: System.Threading.Tasks.Task.ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, System.Object, TResult>, System.Object, System.Threading.CancellationToken, System.Threading.Tasks.TaskContinuationOptions, System.Threading.Tasks.TaskScheduler)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ContinueWith
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 4502
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a continuation that executes based on the specified task continuation options when the target <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes and returns a value. The continuation receives caller-supplied state information and a cancellation token and uses the specified scheduler. </p>\n"
  remarks: "\n<p>The returned <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref> will not be scheduled for execution until the current task has  completed. If the criteria specified through the <em>continuationOptions</em> parameter  are not met, the continuation task will be canceled instead of scheduled.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task<TResult> ContinueWith<TResult>(Func<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Function ContinueWith(Of TResult)(continuationFunction As Func(Of Task, Object, TResult), state As Object, cancellationToken As CancellationToken, continuationOptions As TaskContinuationOptions, scheduler As TaskScheduler) As Task(Of TResult)
    parameters:
    - id: continuationFunction
      type: System.Func{System.Threading.Tasks.Task,System.Object,{TResult}}
      description: "\n<p>A function to run when the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes. When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</p>\n"
    - id: state
      type: System.Object
      description: "\n<p>An object representing data to be used by the continuation function.</p>\n"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\n<p>The <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> that will be assigned to the new continuation task.</p>\n"
    - id: continuationOptions
      type: System.Threading.Tasks.TaskContinuationOptions
      description: "\n<p>Options for when the continuation is scheduled and how it behaves. This includes criteria, such as <xref href=\"System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled\" data-throw-if-not-resolved=\"false\"></xref>, as well as execution options, such as <xref href=\"System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    - id: scheduler
      type: System.Threading.Tasks.TaskScheduler
      description: "\n<p>The <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> to associate with the continuation task and to use for its  execution.</p>\n"
    typeParameters:
    - id: TResult
      description: "\n<p>The type of the result produced by the continuation.</p>\n"
    return:
      type: System.Threading.Tasks.Task{{TResult}}
      description: "\n<p>A new continuation <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>continuationFunction</em> argument is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The <em>continuationOptions</em> argument specifies an invalid value for <xref href=\"System.Threading.Tasks.TaskContinuationOptions\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>scheduler</em> argument is <strong>null</strong>.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The provided <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> has already been disposed.</p>\n"
  nameWithType.vb: Task.ContinueWith(Of TResult)(Func(Of Task, Object, TResult), Object, CancellationToken, TaskContinuationOptions, TaskScheduler)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.Tasks.Task.ContinueWith(Of TResult)(System.Func(Of System.Threading.Tasks.Task, System.Object, TResult), System.Object, System.Threading.CancellationToken, System.Threading.Tasks.TaskContinuationOptions, System.Threading.Tasks.TaskScheduler)
  name.vb: ContinueWith(Of TResult)(Func(Of Task, Object, TResult), Object, CancellationToken, TaskContinuationOptions, TaskScheduler)
- uid: System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)
  commentId: M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)
  id: ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: ContinueWith<TResult>(Func<Task, Object, TResult>, Object, TaskContinuationOptions)
  nameWithType: Task.ContinueWith<TResult>(Func<Task, Object, TResult>, Object, TaskContinuationOptions)
  fullName: System.Threading.Tasks.Task.ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, System.Object, TResult>, System.Object, System.Threading.Tasks.TaskContinuationOptions)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ContinueWith
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 4453
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a continuation that executes based on the specified task continuation options when the target <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes. The continuation receives caller-supplied state information. </p>\n"
  remarks: "\n<p>The returned <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref> will not be scheduled for execution until the current task has completed. If the continuation criteria specified through the <em>continuationOptions</em> parameter are not met, the continuation task will be canceled instead of scheduled.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task<TResult> ContinueWith<TResult>(Func<Task, object, TResult> continuationFunction, object state, TaskContinuationOptions continuationOptions)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Function ContinueWith(Of TResult)(continuationFunction As Func(Of Task, Object, TResult), state As Object, continuationOptions As TaskContinuationOptions) As Task(Of TResult)
    parameters:
    - id: continuationFunction
      type: System.Func{System.Threading.Tasks.Task,System.Object,{TResult}}
      description: "\n<p>A function to run when the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes. When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</p>\n"
    - id: state
      type: System.Object
      description: "\n<p>An object representing data to be used by the continuation function.</p>\n"
    - id: continuationOptions
      type: System.Threading.Tasks.TaskContinuationOptions
      description: "\n<p>Options for when the continuation is scheduled and how it behaves. This includes criteria, such as <xref href=\"System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled\" data-throw-if-not-resolved=\"false\"></xref>, as well as execution options, such as <xref href=\"System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    typeParameters:
    - id: TResult
      description: "\n<p>The type of the result produced by the continuation.</p>\n"
    return:
      type: System.Threading.Tasks.Task{{TResult}}
      description: "\n<p>A new continuation <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>continuationFunction</em> argument is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The <em>continuationOptions</em> argument specifies an invalid value for <xref href=\"System.Threading.Tasks.TaskContinuationOptions\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  nameWithType.vb: Task.ContinueWith(Of TResult)(Func(Of Task, Object, TResult), Object, TaskContinuationOptions)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.Tasks.Task.ContinueWith(Of TResult)(System.Func(Of System.Threading.Tasks.Task, System.Object, TResult), System.Object, System.Threading.Tasks.TaskContinuationOptions)
  name.vb: ContinueWith(Of TResult)(Func(Of Task, Object, TResult), Object, TaskContinuationOptions)
- uid: System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)
  commentId: M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)
  id: ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: ContinueWith<TResult>(Func<Task, Object, TResult>, Object, TaskScheduler)
  nameWithType: Task.ContinueWith<TResult>(Func<Task, Object, TResult>, Object, TaskScheduler)
  fullName: System.Threading.Tasks.Task.ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, System.Object, TResult>, System.Object, System.Threading.Tasks.TaskScheduler)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ContinueWith
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 4414
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a continuation that executes asynchronously when the target <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes. The continuation receives caller-supplied state information and uses a specified scheduler. </p>\n"
  remarks: "\n<p>The returned <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public Task<TResult> ContinueWith<TResult>(Func<Task, object, TResult> continuationFunction, object state, TaskScheduler scheduler)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Function ContinueWith(Of TResult)(continuationFunction As Func(Of Task, Object, TResult), state As Object, scheduler As TaskScheduler) As Task(Of TResult)
    parameters:
    - id: continuationFunction
      type: System.Func{System.Threading.Tasks.Task,System.Object,{TResult}}
      description: "\n<p>A function to run when the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completes.  When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</p>\n"
    - id: state
      type: System.Object
      description: "\n<p>An object representing data to be used by the continuation function.</p>\n"
    - id: scheduler
      type: System.Threading.Tasks.TaskScheduler
      description: "\n<p>The <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> to associate with the continuation task and to use for its execution.</p>\n"
    typeParameters:
    - id: TResult
      description: "\n<p>The type of the result produced by the continuation.</p>\n"
    return:
      type: System.Threading.Tasks.Task{{TResult}}
      description: "\n<p>A new continuation <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>continuationFunction</em> argument is <strong>null</strong>.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>scheduler</em> argument is <strong>null</strong>.</p>\n"
  nameWithType.vb: Task.ContinueWith(Of TResult)(Func(Of Task, Object, TResult), Object, TaskScheduler)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.Tasks.Task.ContinueWith(Of TResult)(System.Func(Of System.Threading.Tasks.Task, System.Object, TResult), System.Object, System.Threading.Tasks.TaskScheduler)
  name.vb: ContinueWith(Of TResult)(Func(Of Task, Object, TResult), Object, TaskScheduler)
- uid: System.Threading.Tasks.Task.Delay(System.Int32)
  commentId: M:System.Threading.Tasks.Task.Delay(System.Int32)
  id: Delay(System.Int32)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Delay(Int32)
  nameWithType: Task.Delay(Int32)
  fullName: System.Threading.Tasks.Task.Delay(System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Delay
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 5825
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a task that completes after a time delay. </p>\n"
  remarks: "\n<p>The <xref href=\"System.Threading.Tasks.Task.Delay(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method is typically used to delay the operation of all or part of a task for a specified time interval. Most commonly, the time delay is introduced: </p>\n<ul><li>\n<p>At the beginning of the task, as the following example shows. </p>System.Threading.Tasks.Task.Delay#5</li><li>\n<p>Sometime while the task is executing. In this case, the call to the <xref href=\"System.Threading.Tasks.Task.Delay(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method executes as a child task within a task, as the following example shows. Note that since the task that calls the <xref href=\"System.Threading.Tasks.Task.Delay(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method executes asynchronously, the parent task must wait for it to complete by using the <strong>await</strong> keyword.  </p>System.Threading.Tasks.Task.Delay#7</li></ul>\n<p>After the specified time delay, the task is completed in the <xref href=\"System.Threading.Tasks.TaskStatus.RanToCompletion\" data-throw-if-not-resolved=\"false\"></xref> state. </p>\n<p>This method depends on the system clock. This means that the time delay will approximately equal the resolution of the system clock if the <em>millisecondsDelay</em> argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems. </p>\n"
  syntax:
    content: public static Task Delay(int millisecondsDelay)
    content.vb: Public Shared Function Delay(millisecondsDelay As Integer) As Task
    parameters:
    - id: millisecondsDelay
      type: System.Int32
      description: "\n<p>The number of milliseconds to wait before completing the returned task, or -1 to wait indefinitely. </p>\n"
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>A task that represents the time delay. </p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The <em>millisecondsDelay</em> argument is less than -1.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)
  commentId: M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)
  id: Delay(System.Int32,System.Threading.CancellationToken)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Delay(Int32, CancellationToken)
  nameWithType: Task.Delay(Int32, CancellationToken)
  fullName: System.Threading.Tasks.Task.Delay(System.Int32, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Delay
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 5847
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a cancellable task that completes after a time delay. </p>\n"
  remarks: "\n<p>If the cancellation token is signaled before the specified time delay, a <xref href=\"System.Threading.Tasks.TaskCanceledException\" data-throw-if-not-resolved=\"false\"></xref> exception results, and the task is completed in the <xref href=\"System.Threading.Tasks.TaskStatus.Canceled\" data-throw-if-not-resolved=\"false\"></xref> state.  Otherwise, the task is completed in the <xref href=\"System.Threading.Tasks.TaskStatus.RanToCompletion\" data-throw-if-not-resolved=\"false\"></xref> state once the specified time delay has elapsed. </p>\n<p>For usage scenarios and additional examples, see the documentation for the <xref href=\"System.Threading.Tasks.Task.Delay(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> overload. </p>\n<p>This method depends on the system clock. This means that the time delay will approximately equal the resolution of the system clock if the <em>millisecondsDelay</em> argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems. </p>\n"
  syntax:
    content: public static Task Delay(int millisecondsDelay, CancellationToken cancellationToken)
    content.vb: Public Shared Function Delay(millisecondsDelay As Integer, cancellationToken As CancellationToken) As Task
    parameters:
    - id: millisecondsDelay
      type: System.Int32
      description: "\n<p>The number of milliseconds to wait before completing the returned task, or -1 to wait indefinitely. </p>\n"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\n<p>The cancellation token that will be checked prior to completing the returned task. </p>\n"
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>A task that represents the time delay. </p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The <em>millisecondsDelay</em> argument is less than -1. </p>\n"
  - type: System.Threading.Tasks.TaskCanceledException
    commentId: T:System.Threading.Tasks.TaskCanceledException
    description: "\n<p>The task has been canceled. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The provided <em>cancellationToken</em> has already been disposed. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Threading.Tasks.Task.Delay(System.TimeSpan)
  commentId: M:System.Threading.Tasks.Task.Delay(System.TimeSpan)
  id: Delay(System.TimeSpan)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Delay(TimeSpan)
  nameWithType: Task.Delay(TimeSpan)
  fullName: System.Threading.Tasks.Task.Delay(System.TimeSpan)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Delay
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 5781
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a task that completes after a specified time interval. </p>\n"
  remarks: "\n<p>After the specified time delay, the task is completed in <xref href=\"System.Threading.Tasks.TaskStatus.RanToCompletion\" data-throw-if-not-resolved=\"false\"></xref> state.</p>\n<p>For usage scenarios and additional examples, see the documentation for the <xref href=\"System.Threading.Tasks.Task.Delay(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> overload. </p>\n<p>This method depends on the system clock. This means that the time delay will approximately equal the resolution of the system clock if the <em>delay</em> argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems. </p>\n"
  syntax:
    content: public static Task Delay(TimeSpan delay)
    content.vb: Public Shared Function Delay(delay As TimeSpan) As Task
    parameters:
    - id: delay
      type: System.TimeSpan
      description: "\n<p>The time span to wait before completing the returned task, or <strong>TimeSpan.FromMilliseconds(-1)</strong> to wait indefinitely. </p>\n"
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>A task that represents the time delay. </p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>delay</em> represents a negative time interval other than <strong>TimeSpan.FromMillseconds(-1)</strong>. </p>\n<p>-or-</p>\n<p>The <em>delay</em> argument's <xref href=\"System.TimeSpan.TotalMilliseconds\" data-throw-if-not-resolved=\"false\"></xref> property is greater than <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)
  commentId: M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)
  id: Delay(System.TimeSpan,System.Threading.CancellationToken)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Delay(TimeSpan, CancellationToken)
  nameWithType: Task.Delay(TimeSpan, CancellationToken)
  fullName: System.Threading.Tasks.Task.Delay(System.TimeSpan, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Delay
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 5803
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a cancellable task that completes after a specified time interval. </p>\n"
  remarks: "\n<p>If the cancellation token is signaled before the specified time delay, a <xref href=\"System.Threading.Tasks.TaskCanceledException\" data-throw-if-not-resolved=\"false\"></xref> exception results, and the task is completed in the <xref href=\"System.Threading.Tasks.TaskStatus.Canceled\" data-throw-if-not-resolved=\"false\"></xref> state.  Otherwise, the task is completed in the <xref href=\"System.Threading.Tasks.TaskStatus.RanToCompletion\" data-throw-if-not-resolved=\"false\"></xref> state once the specified time delay has elapsed. </p>\n<p>For usage scenarios and additional examples, see the documentation for the <xref href=\"System.Threading.Tasks.Task.Delay(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> overload. </p>\n<p>This method depends on the system clock. This means that the time delay will approximately equal the resolution of the system clock if the <em>delay</em> argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems. </p>\n"
  syntax:
    content: public static Task Delay(TimeSpan delay, CancellationToken cancellationToken)
    content.vb: Public Shared Function Delay(delay As TimeSpan, cancellationToken As CancellationToken) As Task
    parameters:
    - id: delay
      type: System.TimeSpan
      description: "\n<p>The time span to wait before completing the returned task, or <strong>TimeSpan.FromMilliseconds(-1)</strong> to wait indefinitely. </p>\n"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\n<p>The cancellation token that will be checked prior to completing the returned task. </p>\n"
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>A task that represents the time delay. </p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>delay</em> represents a negative time interval other than <strong>TimeSpan.FromMillseconds(-1)</strong>. </p>\n<p>-or-</p>\n<p>The <em>delay</em> argument's <xref href=\"System.TimeSpan.TotalMilliseconds\" data-throw-if-not-resolved=\"false\"></xref> property is greater than <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  - type: System.Threading.Tasks.TaskCanceledException
    commentId: T:System.Threading.Tasks.TaskCanceledException
    description: "\n<p>The task has been canceled.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The provided <em>cancellationToken</em> has already been disposed. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)
  commentId: M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)
  id: FromCanceled(System.Threading.CancellationToken)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: FromCanceled(CancellationToken)
  nameWithType: Task.FromCanceled(CancellationToken)
  fullName: System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: FromCanceled
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 5530
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> that's completed due to cancellation with a specified cancellation token.</p>\n"
  syntax:
    content: public static Task FromCanceled(CancellationToken cancellationToken)
    content.vb: Public Shared Function FromCanceled(cancellationToken As CancellationToken) As Task
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\n<p>The cancellation token with which to complete the task. </p>\n"
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>The canceled task. </p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>Cancellation has not been requested for <em>cancellationToken</em>; its <xref href=\"System.Threading.CancellationToken.IsCancellationRequested\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>false</strong>. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)
  commentId: M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)
  id: FromCanceled``1(System.Threading.CancellationToken)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: FromCanceled<TResult>(CancellationToken)
  nameWithType: Task.FromCanceled<TResult>(CancellationToken)
  fullName: System.Threading.Tasks.Task.FromCanceled<TResult>(System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: FromCanceled
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 5542
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref> that's completed due to cancellation with a specified cancellation token.</p>\n"
  syntax:
    content: public static Task<TResult> FromCanceled<TResult>(CancellationToken cancellationToken)
    content.vb: Public Shared Function FromCanceled(Of TResult)(cancellationToken As CancellationToken) As Task(Of TResult)
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\n<p>The cancellation token with which to complete the task. </p>\n"
    typeParameters:
    - id: TResult
      description: "\n<p>The type of the result returned by the task. </p>\n"
    return:
      type: System.Threading.Tasks.Task{{TResult}}
      description: "\n<p>The canceled task. </p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>Cancellation has not been requested for <em>cancellationToken</em>; its <xref href=\"System.Threading.CancellationToken.IsCancellationRequested\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>false</strong>. </p>\n"
  nameWithType.vb: Task.FromCanceled(Of TResult)(CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.FromCanceled(Of TResult)(System.Threading.CancellationToken)
  name.vb: FromCanceled(Of TResult)(CancellationToken)
- uid: System.Threading.Tasks.Task.FromException(System.Exception)
  commentId: M:System.Threading.Tasks.Task.FromException(System.Exception)
  id: FromException(System.Exception)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: FromException(Exception)
  nameWithType: Task.FromException(Exception)
  fullName: System.Threading.Tasks.Task.FromException(System.Exception)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: FromException
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 5507
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> that has completed with a specified exception. </p>\n"
  remarks: "\n<p>This method creates a <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> object whose <xref href=\"System.Threading.Tasks.Task.Status\" data-throw-if-not-resolved=\"false\"></xref> property is <xref href=\"System.Threading.Tasks.TaskStatus.Faulted\" data-throw-if-not-resolved=\"false\"></xref> and whose <xref href=\"System.Threading.Tasks.Task.Exception\" data-throw-if-not-resolved=\"false\"></xref> property contains <em>exception</em>. The method is commonly used when you immediately know that the work that a task performs will throw an exception before executing a longer code path. For an example, see the <xref href=\"System.Threading.Tasks.Task.FromException``1(System.Exception)\" data-throw-if-not-resolved=\"false\"></xref> overload. </p>\n"
  syntax:
    content: public static Task FromException(Exception exception)
    content.vb: Public Shared Function FromException(exception As Exception) As Task
    parameters:
    - id: exception
      type: System.Exception
      description: "\n<p>The exception with which to complete the task. </p>\n"
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>The faulted task. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Threading.Tasks.Task.FromException``1(System.Exception)
  commentId: M:System.Threading.Tasks.Task.FromException``1(System.Exception)
  id: FromException``1(System.Exception)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: FromException<TResult>(Exception)
  nameWithType: Task.FromException<TResult>(Exception)
  fullName: System.Threading.Tasks.Task.FromException<TResult>(System.Exception)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: FromException
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 5516
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref> that's completed with a specified exception. </p>\n"
  remarks: "\n<p>This method creates a <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref> object whose <xref href=\"System.Threading.Tasks.Task.Status\" data-throw-if-not-resolved=\"false\"></xref> property is <xref href=\"System.Threading.Tasks.TaskStatus.Faulted\" data-throw-if-not-resolved=\"false\"></xref> and whose <xref href=\"System.Threading.Tasks.Task.Exception\" data-throw-if-not-resolved=\"false\"></xref> property contains <em>exception</em>. The method is commonly used when you immediately know that the work that a task performs will throw an exception before executing a longer code path. The example provides an illustration. </p>\n"
  syntax:
    content: public static Task<TResult> FromException<TResult>(Exception exception)
    content.vb: Public Shared Function FromException(Of TResult)(exception As Exception) As Task(Of TResult)
    parameters:
    - id: exception
      type: System.Exception
      description: "\n<p>The exception with which to complete the task. </p>\n"
    typeParameters:
    - id: TResult
      description: "\n<p>The type of the result returned by the task. </p>\n"
    return:
      type: System.Threading.Tasks.Task{{TResult}}
      description: "\n<p>The faulted task. </p>\n"
  nameWithType.vb: Task.FromException(Of TResult)(Exception)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.FromException(Of TResult)(System.Exception)
  name.vb: FromException(Of TResult)(Exception)
- uid: System.Threading.Tasks.Task.FromResult``1(``0)
  commentId: M:System.Threading.Tasks.Task.FromResult``1(``0)
  id: FromResult``1(``0)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: FromResult<TResult>(TResult)
  nameWithType: Task.FromResult<TResult>(TResult)
  fullName: System.Threading.Tasks.Task.FromResult<TResult>(TResult)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: FromResult
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 5498
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref> that's completed successfully with the specified result.</p>\n"
  remarks: "\n<p>This method creates a <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref> object whose <xref href=\"System.Threading.Tasks.Task`1.Result\" data-throw-if-not-resolved=\"false\"></xref> property is <em>result</em> and whose <xref href=\"System.Threading.Tasks.Task.Status\" data-throw-if-not-resolved=\"false\"></xref> property is <xref href=\"System.Threading.Tasks.TaskStatus.RanToCompletion\" data-throw-if-not-resolved=\"false\"></xref>. The method is commonly used when the return value of a task is immediately known without executing a longer code path. The example provides an illustration. </p>\n<p>To create a Task object that does not return a value, retrieve the Task object from the <xref href=\"System.Threading.Tasks.Task.CompletedTask\" data-throw-if-not-resolved=\"false\"></xref> property. </p>\n"
  syntax:
    content: public static Task<TResult> FromResult<TResult>(TResult result)
    content.vb: Public Shared Function FromResult(Of TResult)(result As TResult) As Task(Of TResult)
    parameters:
    - id: result
      type: '{TResult}'
      description: "\n<p>The result to store into the completed task. </p>\n"
    typeParameters:
    - id: TResult
      description: "\n<p>The type of the result returned by the task. </p>\n"
    return:
      type: System.Threading.Tasks.Task{{TResult}}
      description: "\n<p>The successfully completed task.</p>\n"
  seealso:
  - type: System.Threading.Tasks.Task.CompletedTask
    commentId: P:System.Threading.Tasks.Task.CompletedTask
  nameWithType.vb: Task.FromResult(Of TResult)(TResult)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.FromResult(Of TResult)(TResult)
  name.vb: FromResult(Of TResult)(TResult)
- uid: System.Threading.Tasks.Task.GetAwaiter
  commentId: M:System.Threading.Tasks.Task.GetAwaiter
  id: GetAwaiter
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: GetAwaiter()
  nameWithType: Task.GetAwaiter()
  fullName: System.Threading.Tasks.Task.GetAwaiter()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: GetAwaiter
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 2904
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Gets an awaiter used to await this <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>This method is intended for compiler use rather than for use in application code. </p>\n"
  syntax:
    content: public TaskAwaiter GetAwaiter()
    content.vb: Public Function GetAwaiter As TaskAwaiter
    return:
      type: System.Runtime.CompilerServices.TaskAwaiter
      description: "\n<p>An awaiter instance.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.Tasks.Task.Run(System.Action)
  commentId: M:System.Threading.Tasks.Task.Run(System.Action)
  id: Run(System.Action)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Run(Action)
  nameWithType: Task.Run(Action)
  fullName: System.Threading.Tasks.Task.Run(System.Action)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Run
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 5597
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Queues the specified work to run on the thread pool and returns a <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> object that represents that work.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Threading.Tasks.Task.Run(System.Action)\" data-throw-if-not-resolved=\"false\"></xref> method allows you to create and execute a task in a single method call and is a simpler alternative to the <xref href=\"System.Threading.Tasks.TaskFactory.StartNew(System.Action)\" data-throw-if-not-resolved=\"false\"></xref> method. It creates a task with the following default values: </p>\n<ul><li>\n<p>Its cancellation token is <xref href=\"System.Threading.CancellationToken.None\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n</li><li>\n<p>Its <xref href=\"System.Threading.Tasks.Task.CreationOptions\" data-throw-if-not-resolved=\"false\"></xref> property value is <xref href=\"System.Threading.Tasks.TaskCreationOptions.DenyChildAttach\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n</li><li>\n<p>It uses the default task scheduler. </p>\n</li></ul>\n<p>For information on handling exceptions thrown by task operations, see Exception Handling (Task Parallel Library).</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public static Task Run(Action action)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Shared Function Run(action As Action) As Task
    parameters:
    - id: action
      type: System.Action
      description: "\n<p>The work to execute asynchronously</p>\n"
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>A task that represents the work queued to execute in the ThreadPool.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>action</em> parameter was <strong>null</strong>.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)
  commentId: M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)
  id: Run(System.Action,System.Threading.CancellationToken)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Run(Action, CancellationToken)
  nameWithType: Task.Run(Action, CancellationToken)
  fullName: System.Threading.Tasks.Task.Run(System.Action, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Run
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 5617
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Queues the specified work to run on the thread pool and returns a <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> object that represents that work. A cancellation token allows the work to be cancelled.</p>\n"
  remarks: "\n<p>If cancellation is requested before the task begins execution, the task does not execute. Instead it is set to the <xref href=\"System.Threading.Tasks.TaskStatus.Canceled\" data-throw-if-not-resolved=\"false\"></xref> state and throws a <xref href=\"System.Threading.Tasks.TaskCanceledException\" data-throw-if-not-resolved=\"false\"></xref> exception.</p>\n<p>The <xref href=\"System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)\" data-throw-if-not-resolved=\"false\"></xref> method is a simpler alternative to the <xref href=\"System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken)\" data-throw-if-not-resolved=\"false\"></xref>  method. It creates a task with the following default values: </p>\n<ul><li>\n<p>Its <xref href=\"System.Threading.Tasks.Task.CreationOptions\" data-throw-if-not-resolved=\"false\"></xref> property value is <xref href=\"System.Threading.Tasks.TaskCreationOptions.DenyChildAttach\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n</li><li>\n<p>It uses the default task scheduler. </p>\n</li></ul>\n<p>For information on handling exceptions thrown by task operations, see Exception Handling (Task Parallel Library).</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public static Task Run(Action action, CancellationToken cancellationToken)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Shared Function Run(action As Action, cancellationToken As CancellationToken) As Task
    parameters:
    - id: action
      type: System.Action
      description: "\n<p>The work to execute asynchronously</p>\n"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\n<p>A cancellation token that can be used to cancel the work</p>\n"
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>A task that represents the work queued to execute in the thread pool.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>action</em> parameter was <strong>null</strong>.</p>\n"
  - type: System.Threading.Tasks.TaskCanceledException
    commentId: T:System.Threading.Tasks.TaskCanceledException
    description: "\n<p>The task has been canceled.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> associated with <em>cancellationToken</em> was disposed.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})
  commentId: M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})
  id: Run(System.Func{System.Threading.Tasks.Task})
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Run(Func<Task>)
  nameWithType: Task.Run(Func<Task>)
  fullName: System.Threading.Tasks.Task.Run(System.Func<System.Threading.Tasks.Task>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Run
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 5670
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Queues the specified work to run on the thread pool and returns a proxy for the  task returned by <em>function</em>.</p>\n"
  remarks: "\n<p>For information on handling exceptions thrown by task operations, see Exception Handling (Task Parallel Library).</p>\n"
  syntax:
    content: public static Task Run(Func<Task> function)
    content.vb: Public Shared Function Run(function As Func(Of Task)) As Task
    parameters:
    - id: function
      type: System.Func{System.Threading.Tasks.Task}
      description: "\n<p>The work to execute asynchronously</p>\n"
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>A task that represents a proxy for the task returned by <em>function</em>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>function</em> parameter was <strong>null</strong>.</p>\n"
  nameWithType.vb: Task.Run(Func(Of Task))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.Run(System.Func(Of System.Threading.Tasks.Task))
  name.vb: Run(Func(Of Task))
- uid: System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)
  commentId: M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)
  id: Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Run(Func<Task>, CancellationToken)
  nameWithType: Task.Run(Func<Task>, CancellationToken)
  fullName: System.Threading.Tasks.Task.Run(System.Func<System.Threading.Tasks.Task>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Run
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 5689
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Queues the specified work to run on the thread pool and returns a proxy for the task returned by <em>function</em>.</p>\n"
  remarks: "\n<p>For information on handling exceptions thrown by task operations, see Exception Handling (Task Parallel Library).</p>\n"
  syntax:
    content: public static Task Run(Func<Task> function, CancellationToken cancellationToken)
    content.vb: Public Shared Function Run(function As Func(Of Task), cancellationToken As CancellationToken) As Task
    parameters:
    - id: function
      type: System.Func{System.Threading.Tasks.Task}
      description: "\n<p>The work to execute asynchronously. </p>\n"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\n<p>A cancellation token that should be used to cancel the work. </p>\n"
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>A task that represents a proxy for the task returned by <em>function</em>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>function</em> parameter was <strong>null</strong>.</p>\n"
  - type: System.Threading.Tasks.TaskCanceledException
    commentId: T:System.Threading.Tasks.TaskCanceledException
    description: "\n<p>The task has been canceled.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> associated with <em>cancellationToken</em> was disposed.</p>\n"
  nameWithType.vb: Task.Run(Func(Of Task), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.Run(System.Func(Of System.Threading.Tasks.Task), System.Threading.CancellationToken)
  name.vb: Run(Func(Of Task), CancellationToken)
- uid: System.Threading.Tasks.Task.Run``1(System.Func{``0})
  commentId: M:System.Threading.Tasks.Task.Run``1(System.Func{``0})
  id: Run``1(System.Func{``0})
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Run<TResult>(Func<TResult>)
  nameWithType: Task.Run<TResult>(Func<TResult>)
  fullName: System.Threading.Tasks.Task.Run<TResult>(System.Func<TResult>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Run
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 5633
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Queues the specified work to run on the thread pool and returns a <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref> object that represents that work. </p>\n"
  remarks: "\n<p>The <xref href=\"System.Threading.Tasks.Task.Run``1(System.Func{``0})\" data-throw-if-not-resolved=\"false\"></xref> method is a simpler alternative to the <xref href=\"System.Threading.Tasks.TaskFactory.StartNew(System.Action)\" data-throw-if-not-resolved=\"false\"></xref> method. It creates a task with the following default values: </p>\n<ul><li>\n<p>Its cancellation token is <xref href=\"System.Threading.CancellationToken.None\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n</li><li>\n<p>Its <xref href=\"System.Threading.Tasks.Task.CreationOptions\" data-throw-if-not-resolved=\"false\"></xref> property value is <xref href=\"System.Threading.Tasks.TaskCreationOptions.DenyChildAttach\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n</li><li>\n<p>It uses the default task scheduler. </p>\n</li></ul>\n<p>For information on handling exceptions thrown by task operations, see Exception Handling (Task Parallel Library).</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public static Task<TResult> Run<TResult>(Func<TResult> function)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Shared Function Run(Of TResult)(function As Func(Of TResult)) As Task(Of TResult)
    parameters:
    - id: function
      type: System.Func{{TResult}}
      description: "\n<p>The work to execute asynchronously. </p>\n"
    typeParameters:
    - id: TResult
      description: "\n<p>The return type of the task. </p>\n"
    return:
      type: System.Threading.Tasks.Task{{TResult}}
      description: "\n<p>A task object that represents the work queued to execute in the thread pool. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>function</em> parameter is <strong>null</strong>. </p>\n"
  nameWithType.vb: Task.Run(Of TResult)(Func(Of TResult))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.Run(Of TResult)(System.Func(Of TResult))
  name.vb: Run(Of TResult)(Func(Of TResult))
- uid: System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)
  commentId: M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)
  id: Run``1(System.Func{``0},System.Threading.CancellationToken)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Run<TResult>(Func<TResult>, CancellationToken)
  nameWithType: Task.Run<TResult>(Func<TResult>, CancellationToken)
  fullName: System.Threading.Tasks.Task.Run<TResult>(System.Func<TResult>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Run
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 5653
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Queues the specified work to run on the thread pool and returns a <strong>Task(TResult)</strong> object that represents that work. A cancellation token allows the work to be cancelled.</p>\n"
  remarks: "\n<p>If cancellation is requested before the task begins execution, the task does not execute. Instead it is set to the <xref href=\"System.Threading.Tasks.TaskStatus.Canceled\" data-throw-if-not-resolved=\"false\"></xref> state and throws a <xref href=\"System.Threading.Tasks.TaskCanceledException\" data-throw-if-not-resolved=\"false\"></xref> exception.</p>\n<p>The <xref href=\"System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)\" data-throw-if-not-resolved=\"false\"></xref> method is a simpler alternative to the <xref href=\"System.Threading.Tasks.TaskFactory.StartNew(System.Action)\" data-throw-if-not-resolved=\"false\"></xref> method. It creates a task with the following default values: </p>\n<ul><li>\n<p>Its <xref href=\"System.Threading.Tasks.Task.CreationOptions\" data-throw-if-not-resolved=\"false\"></xref> property value is <xref href=\"System.Threading.Tasks.TaskCreationOptions.DenyChildAttach\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n</li><li>\n<p>It uses the default task scheduler. </p>\n</li></ul>\n<p>For information on handling exceptions thrown by task operations, see Exception Handling (Task Parallel Library).</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoInlining)]

      public static Task<TResult> Run<TResult>(Func<TResult> function, CancellationToken cancellationToken)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoInlining)>

      Public Shared Function Run(Of TResult)(function As Func(Of TResult), cancellationToken As CancellationToken) As Task(Of TResult)
    parameters:
    - id: function
      type: System.Func{{TResult}}
      description: "\n<p>The work to execute asynchronously</p>\n"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\n<p>A cancellation token that should be used to cancel the work</p>\n"
    typeParameters:
    - id: TResult
      description: "\n<p>The result type of the task.</p>\n"
    return:
      type: System.Threading.Tasks.Task{{TResult}}
      description: "\n<p>A <strong>Task(TResult)</strong> that represents the work queued to execute in the thread pool.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>function</em> parameter is <strong>null</strong>.</p>\n"
  - type: System.Threading.Tasks.TaskCanceledException
    commentId: T:System.Threading.Tasks.TaskCanceledException
    description: "\n<p>The task has been canceled.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> associated with <em>cancellationToken</em> was disposed.</p>\n"
  nameWithType.vb: Task.Run(Of TResult)(Func(Of TResult), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.Run(Of TResult)(System.Func(Of TResult), System.Threading.CancellationToken)
  name.vb: Run(Of TResult)(Func(Of TResult), CancellationToken)
- uid: System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})
  commentId: M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})
  id: Run``1(System.Func{System.Threading.Tasks.Task{``0}})
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Run<TResult>(Func<Task<TResult>>)
  nameWithType: Task.Run<TResult>(Func<Task<TResult>>)
  fullName: System.Threading.Tasks.Task.Run<TResult>(System.Func<System.Threading.Tasks.Task<TResult>>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Run
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 5724
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Queues the specified work to run on the thread pool and returns a proxy for the <strong>Task(TResult)</strong> returned by <em>function</em>.</p>\n"
  remarks: "\n<p>For information on handling exceptions thrown by task operations, see Exception Handling (Task Parallel Library).</p>\n"
  syntax:
    content: public static Task<TResult> Run<TResult>(Func<Task<TResult>> function)
    content.vb: Public Shared Function Run(Of TResult)(function As Func(Of Task(Of TResult))) As Task(Of TResult)
    parameters:
    - id: function
      type: System.Func{System.Threading.Tasks.Task{{TResult}}}
      description: "\n<p>The work to execute asynchronously</p>\n"
    typeParameters:
    - id: TResult
      description: "\n<p>The type of the result returned by the proxy task.</p>\n"
    return:
      type: System.Threading.Tasks.Task{{TResult}}
      description: "\n<p>A <strong>Task(TResult)</strong> that represents a proxy for the <strong>Task(TResult)</strong> returned by <em>function</em>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>function</em> parameter was <strong>null</strong>.</p>\n"
  nameWithType.vb: Task.Run(Of TResult)(Func(Of Task(Of TResult)))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.Run(Of TResult)(System.Func(Of System.Threading.Tasks.Task(Of TResult)))
  name.vb: Run(Of TResult)(Func(Of Task(Of TResult)))
- uid: System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)
  commentId: M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)
  id: Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Run<TResult>(Func<Task<TResult>>, CancellationToken)
  nameWithType: Task.Run<TResult>(Func<Task<TResult>>, CancellationToken)
  fullName: System.Threading.Tasks.Task.Run<TResult>(System.Func<System.Threading.Tasks.Task<TResult>>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Run
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 5740
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Queues the specified work to run on the thread pool and returns a proxy for the <strong>Task(TResult)</strong> returned by <em>function</em>.</p>\n"
  remarks: "\n<p>For information on handling exceptions thrown by task operations, see Exception Handling (Task Parallel Library).</p>\n"
  syntax:
    content: public static Task<TResult> Run<TResult>(Func<Task<TResult>> function, CancellationToken cancellationToken)
    content.vb: Public Shared Function Run(Of TResult)(function As Func(Of Task(Of TResult)), cancellationToken As CancellationToken) As Task(Of TResult)
    parameters:
    - id: function
      type: System.Func{System.Threading.Tasks.Task{{TResult}}}
      description: "\n<p>The work to execute asynchronously</p>\n"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\n<p>A cancellation token that should be used to cancel the work</p>\n"
    typeParameters:
    - id: TResult
      description: "\n<p>The type of the result returned by the proxy task.</p>\n"
    return:
      type: System.Threading.Tasks.Task{{TResult}}
      description: "\n<p>A <strong>Task(TResult)</strong> that represents a proxy for the <strong>Task(TResult)</strong> returned by <em>function</em>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>function</em> parameter was <strong>null</strong>.</p>\n"
  - type: System.Threading.Tasks.TaskCanceledException
    commentId: T:System.Threading.Tasks.TaskCanceledException
    description: "\n<p>The task has been canceled.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> associated with <em>cancellationToken</em> was disposed.</p>\n"
  nameWithType.vb: Task.Run(Of TResult)(Func(Of Task(Of TResult)), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.Run(Of TResult)(System.Func(Of System.Threading.Tasks.Task(Of TResult)), System.Threading.CancellationToken)
  name.vb: Run(Of TResult)(Func(Of Task(Of TResult)), CancellationToken)
- uid: System.Threading.Tasks.Task.RunSynchronously
  commentId: M:System.Threading.Tasks.Task.RunSynchronously
  id: RunSynchronously
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: RunSynchronously()
  nameWithType: Task.RunSynchronously()
  fullName: System.Threading.Tasks.Task.RunSynchronously()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: RunSynchronously
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 1121
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Runs the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> synchronously on the current <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>Ordinarily, tasks are executed asynchronously on a thread pool thread and do not block the calling thread. Tasks executed by calling the <xref href=\"System.Threading.Tasks.Task.RunSynchronously\" data-throw-if-not-resolved=\"false\"></xref> method are associated with the current <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> and are run on the calling thread. If the target scheduler does not support running this task on the calling thread, the task will be scheduled for execution on the scheduler, and the calling thread will block until the task has completed execution. Even though the task runs synchronously, the calling thread should still call <xref href=\"System.Threading.Tasks.Task.Wait\" data-throw-if-not-resolved=\"false\"></xref> to handle any exceptions that the task might throw.  For more information on exception handling, see Exception Handling (Task Parallel Library).</p>\n<p>Tasks executed by calling the <xref href=\"System.Threading.Tasks.Task.RunSynchronously\" data-throw-if-not-resolved=\"false\"></xref> method are instantiated by calling a <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref> class constructor. The task to be run synchronously must be in the <xref href=\"System.Threading.Tasks.TaskStatus.Created\" data-throw-if-not-resolved=\"false\"></xref> state. A task may be started and run only once. Any attempts to schedule a task a second time results in an exception. </p>\n"
  syntax:
    content: public void RunSynchronously()
    content.vb: Public Sub RunSynchronously
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instance has been disposed.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> is not in a valid state to be started. It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)
  commentId: M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)
  id: RunSynchronously(System.Threading.Tasks.TaskScheduler)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: RunSynchronously(TaskScheduler)
  nameWithType: Task.RunSynchronously(TaskScheduler)
  fullName: System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: RunSynchronously
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 1149
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Runs the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> synchronously on the <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> provided.</p>\n"
  remarks: "\n<p>Tasks executed by calling the <xref href=\"System.Threading.Tasks.Task.RunSynchronously\" data-throw-if-not-resolved=\"false\"></xref> method are instantiated by calling a <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref> class constructor. The task to be run synchronously must be in the <xref href=\"System.Threading.Tasks.TaskStatus.Created\" data-throw-if-not-resolved=\"false\"></xref> state. A task may be started and run only once. Any attempts to schedule a task a second time results in an exception.</p>\n<p>  If the target scheduler does not support running this task on the current thread, the task will be scheduled for execution on the scheduler, and the current thread will block until the task has completed execution. Because of this, the calling thread does not need to call a method such as <xref href=\"System.Threading.Tasks.Task.Wait\" data-throw-if-not-resolved=\"false\"></xref> to ensure that the task has completed execution. For more information on exception handling for task operations, see Exception Handling (Task Parallel Library).</p>\n<p></p>\n"
  syntax:
    content: public void RunSynchronously(TaskScheduler scheduler)
    content.vb: Public Sub RunSynchronously(scheduler As TaskScheduler)
    parameters:
    - id: scheduler
      type: System.Threading.Tasks.TaskScheduler
      description: "\n<p>The scheduler on which to attempt to run this task inline.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instance has been disposed.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>scheduler</em> argument is <strong>null</strong>.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> is not in a valid state to be started. It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</p>\n"
  seealso:
  - type: System.Threading.Tasks.TaskScheduler
    commentId: T:System.Threading.Tasks.TaskScheduler
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.Tasks.Task.Start
  commentId: M:System.Threading.Tasks.Task.Start
  id: Start
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Start()
  nameWithType: Task.Start()
  fullName: System.Threading.Tasks.Task.Start()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Start
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 1036
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Starts the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref>, scheduling it for execution to the current <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>A task may be started and run only once. Any attempts to schedule a task a second time will result in an exception.</p>\n<p>The <xref href=\"System.Threading.Tasks.Task.Start\" data-throw-if-not-resolved=\"false\"></xref> is used to execute a task that has been created by calling one of the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> constructors. Typically, you do this when you need to separate the task's creation from its execution, such as when you conditionally execute tasks that you've created. For the more common case in which you don't need to separate  task instantiation from execution, we recommend that you call an overload of the <xref href=\"System.Threading.Tasks.Task.Run(System.Action)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Threading.Tasks.TaskFactory.StartNew(System.Action)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>For information on handling exceptions thrown by task operations, see Exception Handling (Task Parallel Library).</p>\n"
  syntax:
    content: public void Start()
    content.vb: Public Sub Start
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instance has been disposed.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> is not in a valid state to be started. It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)
  commentId: M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)
  id: Start(System.Threading.Tasks.TaskScheduler)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Start(TaskScheduler)
  nameWithType: Task.Start(TaskScheduler)
  fullName: System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Start
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 1061
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Starts the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref>, scheduling it for execution to the specified <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>A task may only be started and run only once. Any attempts to schedule a task a second time will result in an exception.</p>\n<p>For information on handling exceptions thrown by task operations, see Exception Handling (Task Parallel Library).</p>\n"
  syntax:
    content: public void Start(TaskScheduler scheduler)
    content.vb: Public Sub Start(scheduler As TaskScheduler)
    parameters:
    - id: scheduler
      type: System.Threading.Tasks.TaskScheduler
      description: "\n<p>The <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> with which to associate and execute this task.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>scheduler</em> argument is <strong>null</strong>.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> is not in a valid state to be started. It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instance has been disposed.</p>\n"
  - type: System.Threading.Tasks.TaskSchedulerException
    commentId: T:System.Threading.Tasks.TaskSchedulerException
    description: "\n<p>The scheduler was unable to queue this task.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.Tasks.Task.Wait
  commentId: M:System.Threading.Tasks.Task.Wait
  id: Wait
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Wait()
  nameWithType: Task.Wait()
  fullName: System.Threading.Tasks.Task.Wait()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Wait
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 3013
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Waits for the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> to complete execution.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Threading.Tasks.Task.Wait\" data-throw-if-not-resolved=\"false\"></xref> is a synchronization method that causes the calling thread to wait until the current task has completed. If the current task has not started execution, the Wait method attempts to remove the task from the scheduler and execute it inline on the current thread. If it is unable to do that, or if the current task has already started execution, it blocks the calling thread until the task completes. For more information, see <see href=\"http://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx\">Task.Wait and \"Inlining\"</see> in the Parallel Programming with .NET blog. </p>\n<p>For more information and an example, see How to: Wait on One or More Tasks to Complete.</p>\n"
  syntax:
    content: public void Wait()
    content.vb: Public Sub Wait
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> has been disposed.</p>\n"
  - type: System.AggregateException
    commentId: T:System.AggregateException
    description: "\n<p>The task was canceled. The <xref href=\"System.AggregateException.InnerExceptions\" data-throw-if-not-resolved=\"false\"></xref> collection contains a <xref href=\"System.Threading.Tasks.TaskCanceledException\" data-throw-if-not-resolved=\"false\"></xref> object. </p>\n<p>-or-</p>\n<p>An exception was thrown during the execution of the task. The <xref href=\"System.AggregateException.InnerExceptions\" data-throw-if-not-resolved=\"false\"></xref> collection contains information about the exception or exceptions. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.Tasks.Task.Wait(System.Int32)
  commentId: M:System.Threading.Tasks.Task.Wait(System.Int32)
  id: Wait(System.Int32)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Wait(Int32)
  nameWithType: Task.Wait(Int32)
  fullName: System.Threading.Tasks.Task.Wait(System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Wait
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 3092
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Waits for the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> to complete execution within a specified number of milliseconds.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Threading.Tasks.Task.Wait(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs: </p>\n<ul><li>\n<p>The task completes successfully. </p>\n</li><li>\n<p>The task itself is canceled or throws an exception. In this case, you handle an <xref href=\"System.AggregateException\" data-throw-if-not-resolved=\"false\"></xref> exception. The <xref href=\"System.AggregateException.InnerExceptions\" data-throw-if-not-resolved=\"false\"></xref> property contains details about the exception or exceptions. </p>\n</li><li>\n<p>The interval defined by <em>millisecondsTimeout</em> elapses. In this case, the current thread resumes execution and the method returns <strong>false</strong>.   </p>\n</li></ul>\n"
  syntax:
    content: public bool Wait(int millisecondsTimeout)
    content.vb: Public Function Wait(millisecondsTimeout As Integer) As Boolean
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "\n<p>The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref> (-1) to wait indefinitely.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completed execution within the allotted time; otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> has been disposed.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>millisecondsTimeout</em> is a negative number other than -1, which represents an infinite time-out.</p>\n"
  - type: System.AggregateException
    commentId: T:System.AggregateException
    description: "\n<p>The task was canceled. The <xref href=\"System.AggregateException.InnerExceptions\" data-throw-if-not-resolved=\"false\"></xref> collection contains a <xref href=\"System.Threading.Tasks.TaskCanceledException\" data-throw-if-not-resolved=\"false\"></xref> object. </p>\n<p>-or-</p>\n<p>An exception was thrown during the execution of the task. The <xref href=\"System.AggregateException.InnerExceptions\" data-throw-if-not-resolved=\"false\"></xref> collection contains information about the exception or exceptions. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)
  commentId: M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)
  id: Wait(System.Int32,System.Threading.CancellationToken)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Wait(Int32, CancellationToken)
  nameWithType: Task.Wait(Int32, CancellationToken)
  fullName: System.Threading.Tasks.Task.Wait(System.Int32, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Wait
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 3122
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Waits for the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> to complete execution. The wait terminates if a timeout interval elapses or a cancellation token is canceled before the task completes. </p>\n"
  remarks: "\n<p>\n<xref href=\"System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)\" data-throw-if-not-resolved=\"false\"></xref> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs: </p>\n<ul><li>\n<p>The task completes successfully. </p>\n</li><li>\n<p>The task itself is canceled or throws an exception. In this case, you handle an <xref href=\"System.AggregateException\" data-throw-if-not-resolved=\"false\"></xref> exception. The <xref href=\"System.AggregateException.InnerExceptions\" data-throw-if-not-resolved=\"false\"></xref> property contains details about the exception or exceptions. </p>\n</li><li>\n<p>The <em>cancellationToken</em> cancellation token is canceled. In this case, the call to the <xref href=\"System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)\" data-throw-if-not-resolved=\"false\"></xref> method throws an <xref href=\"System.OperationCanceledException\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n</li><li>\n<p>The interval defined by <em>millisecondsTimeout</em> elapses. In this case, the current thread resumes execution and the method returns <strong>false</strong>. </p>\n</li></ul>\n<p>Canceling the <em>cancellationToken</em> cancellation token has no effect on the running task unless it has also been passed the cancellation token and is prepared to handle cancellation. Passing the <em>cancellationToken</em> object to this method simply allows the wait to be canceled based on some condition. </p>\n"
  syntax:
    content: public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken)
    content.vb: Public Function Wait(millisecondsTimeout As Integer, cancellationToken As CancellationToken) As Boolean
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "\n<p>The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref> (-1) to wait indefinitely. </p>\n"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\n<p>A cancellation token to observe while waiting for the task to complete. </p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completed execution within the allotted time; otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.OperationCanceledException
    commentId: T:System.OperationCanceledException
    description: "\n<p>The <em>cancellationToken</em> was canceled.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> has been disposed.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>millisecondsTimeout</em> is a negative number other than -1, which represents an infinite time-out.</p>\n"
  - type: System.AggregateException
    commentId: T:System.AggregateException
    description: "\n<p>The task was canceled. The <xref href=\"System.AggregateException.InnerExceptions\" data-throw-if-not-resolved=\"false\"></xref> collection contains a <xref href=\"System.Threading.Tasks.TaskCanceledException\" data-throw-if-not-resolved=\"false\"></xref> object. </p>\n<p>-or-</p>\n<p>An exception was thrown during the execution of the task. The <xref href=\"System.AggregateException.InnerExceptions\" data-throw-if-not-resolved=\"false\"></xref> collection contains information about the exception or exceptions. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)
  commentId: M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)
  id: Wait(System.Threading.CancellationToken)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Wait(CancellationToken)
  nameWithType: Task.Wait(CancellationToken)
  fullName: System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Wait
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 3069
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Waits for the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> to complete execution. The wait terminates if a cancellation token is canceled before the task completes. </p>\n"
  remarks: "\n<p>The <xref href=\"System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)\" data-throw-if-not-resolved=\"false\"></xref> method creates a cancelable wait; that is, it causes the current thread to wait until one of the following occurs: </p>\n<ul><li>\n<p>The task completes. </p>\n</li><li>\n<p>The cancellation token is canceled. In this case, the call to the <xref href=\"System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)\" data-throw-if-not-resolved=\"false\"></xref> method throws an <xref href=\"System.OperationCanceledException\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n</li></ul>\n<p>Canceling the <em>cancellationToken</em> cancellation token has no effect on the running task unless it has also been passed the cancellation token and is prepared to handle cancellation. Passing the <em>cancellationToken</em> object to this method simply allows the wait to be canceled. </p>\n"
  syntax:
    content: public void Wait(CancellationToken cancellationToken)
    content.vb: Public Sub Wait(cancellationToken As CancellationToken)
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\n<p>A cancellation token to observe while waiting for the task to complete. </p>\n"
  exceptions:
  - type: System.OperationCanceledException
    commentId: T:System.OperationCanceledException
    description: "\n<p>The <em>cancellationToken</em> was canceled.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The task has been disposed.</p>\n"
  - type: System.AggregateException
    commentId: T:System.AggregateException
    description: "\n<p>The task was canceled. The <xref href=\"System.AggregateException.InnerExceptions\" data-throw-if-not-resolved=\"false\"></xref> collection contains a <xref href=\"System.Threading.Tasks.TaskCanceledException\" data-throw-if-not-resolved=\"false\"></xref> object. </p>\n<p>-or-</p>\n<p>An exception was thrown during the execution of the task. The <xref href=\"System.AggregateException.InnerExceptions\" data-throw-if-not-resolved=\"false\"></xref> collection contains information about the exception or exceptions. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.Tasks.Task.Wait(System.TimeSpan)
  commentId: M:System.Threading.Tasks.Task.Wait(System.TimeSpan)
  id: Wait(System.TimeSpan)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Wait(TimeSpan)
  nameWithType: Task.Wait(TimeSpan)
  fullName: System.Threading.Tasks.Task.Wait(System.TimeSpan)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Wait
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 3044
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Waits for the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> to complete execution within a specified time interval.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Threading.Tasks.Task.Wait(System.TimeSpan)\" data-throw-if-not-resolved=\"false\"></xref> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs: </p>\n<ul><li>\n<p>The task completes successfully. </p>\n</li><li>\n<p>The task itself is canceled or throws an exception. In this case, you handle an <xref href=\"System.AggregateException\" data-throw-if-not-resolved=\"false\"></xref> exception. The <xref href=\"System.AggregateException.InnerExceptions\" data-throw-if-not-resolved=\"false\"></xref> property contains details about the exception or exceptions. </p>\n</li><li>\n<p>The interval defined by <em>timeout</em> elapses. In this case, the current thread resumes execution and the method returns <strong>false</strong>.   </p>\n</li></ul>\n"
  syntax:
    content: public bool Wait(TimeSpan timeout)
    content.vb: Public Function Wait(timeout As TimeSpan) As Boolean
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "\n<p>A <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> that represents -1 milliseconds to wait indefinitely.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> completed execution within the allotted time; otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> has been disposed.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>timeout</em> is a negative number other than -1 milliseconds, which represents an infinite time-out. </p>\n<p>-or-</p>\n<p>\n<em>timeout</em> is greater than <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  - type: System.AggregateException
    commentId: T:System.AggregateException
    description: "\n<p>The task was canceled. The <xref href=\"System.AggregateException.InnerExceptions\" data-throw-if-not-resolved=\"false\"></xref> collection contains a <xref href=\"System.Threading.Tasks.TaskCanceledException\" data-throw-if-not-resolved=\"false\"></xref> object. </p>\n<p>-or-</p>\n<p>An exception was thrown during the execution of the task. The <xref href=\"System.AggregateException.InnerExceptions\" data-throw-if-not-resolved=\"false\"></xref> collection contains information about the exception or exceptions. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])
  commentId: M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])
  id: WaitAll(System.Threading.Tasks.Task[])
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: WaitAll(Task[])
  nameWithType: Task.WaitAll(Task[])
  fullName: System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: WaitAll
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 4866
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Waits for all of the provided <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> objects to complete execution.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoOptimization)]

      public static void WaitAll(params Task[] tasks)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoOptimization)>

      Public Shared Sub WaitAll(ParamArray tasks As Task())
    parameters:
    - id: tasks
      type: System.Threading.Tasks.Task[]
      description: "\n<p>An array of <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances on which to wait.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>One or more of the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> objects in <em>tasks</em> has been disposed.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>tasks</em> argument is <strong>null</strong>.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>tasks</em> argument contains a null element.</p>\n<p>-or-</p>\n<p>The <em>tasks</em> argument is an empty array.</p>\n"
  - type: System.AggregateException
    commentId: T:System.AggregateException
    description: "\n<p>At least one of the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances was canceled. If a task was canceled, the <xref href=\"System.AggregateException\" data-throw-if-not-resolved=\"false\"></xref> exception contains an <xref href=\"System.OperationCanceledException\" data-throw-if-not-resolved=\"false\"></xref> exception in its <xref href=\"System.AggregateException.InnerExceptions\" data-throw-if-not-resolved=\"false\"></xref> collection.</p>\n<p>-or-</p>\n<p>An exception was thrown during the execution of at least one of the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances. </p>\n"
  nameWithType.vb: Task.WaitAll(Task())
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task())
  name.vb: WaitAll(Task())
- uid: System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)
  commentId: M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)
  id: WaitAll(System.Threading.Tasks.Task[],System.Int32)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: WaitAll(Task[], Int32)
  nameWithType: Task.WaitAll(Task[], Int32)
  fullName: System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[], System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: WaitAll
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 4947
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Waits for all of the provided <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> objects to complete execution within a specified number of milliseconds.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoOptimization)]

      public static bool WaitAll(Task[] tasks, int millisecondsTimeout)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoOptimization)>

      Public Shared Function WaitAll(tasks As Task(), millisecondsTimeout As Integer) As Boolean
    parameters:
    - id: tasks
      type: System.Threading.Tasks.Task[]
      description: "\n<p>An array of <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances on which to wait.</p>\n<p></p>\n"
    - id: millisecondsTimeout
      type: System.Int32
      description: "\n<p>The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref> (-1) to wait indefinitely.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if all of the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances completed execution within the allotted time; otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>One or more of the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> objects in <em>tasks</em> has been disposed.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>tasks</em> argument is <strong>null</strong>.</p>\n"
  - type: System.AggregateException
    commentId: T:System.AggregateException
    description: "\n<p>At least one of the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances was canceled. If a task was canceled, the <xref href=\"System.AggregateException\" data-throw-if-not-resolved=\"false\"></xref> contains an <xref href=\"System.OperationCanceledException\" data-throw-if-not-resolved=\"false\"></xref> in its <xref href=\"System.AggregateException.InnerExceptions\" data-throw-if-not-resolved=\"false\"></xref> collection. </p>\n<p>-or-</p>\n<p>An exception was thrown during the execution of at least one of the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>millisecondsTimeout</em> is a negative number other than -1, which represents an infinite time-out.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>tasks</em> argument contains a null element.</p>\n<p>-or-</p>\n<p>The <em>tasks</em> argument is an empty array.</p>\n"
  nameWithType.vb: Task.WaitAll(Task(), Int32)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task(), System.Int32)
  name.vb: WaitAll(Task(), Int32)
- uid: System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)
  commentId: M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)
  id: WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: WaitAll(Task[], Int32, CancellationToken)
  nameWithType: Task.WaitAll(Task[], Int32, CancellationToken)
  fullName: System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[], System.Int32, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: WaitAll
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 5019
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Waits for all of the provided <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> objects to complete execution within a specified number of milliseconds or until the wait is cancelled.</p>\n"
  remarks: "\n<p>The <em>cancellationToken</em> argument is used to cancel the wait operation. Cancellation of the tasks is a distinct operation, and is signaled by the <xref href=\"System.AggregateException\" data-throw-if-not-resolved=\"false\"></xref> noted above.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoOptimization)]

      public static bool WaitAll(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoOptimization)>

      Public Shared Function WaitAll(tasks As Task(), millisecondsTimeout As Integer, cancellationToken As CancellationToken) As Boolean
    parameters:
    - id: tasks
      type: System.Threading.Tasks.Task[]
      description: "\n<p>An array of <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances on which to wait.</p>\n"
    - id: millisecondsTimeout
      type: System.Int32
      description: "\n<p>The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref> (-1) to wait indefinitely.</p>\n"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\n<p>A <xref href=\"System.Threading.Tasks.TaskFactory.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> to observe while waiting for the tasks to complete.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if all of the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances completed execution within the allotted time; otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>One or more of the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> objects in <em>tasks</em> has been disposed.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>tasks</em> argument is <strong>null</strong>.</p>\n"
  - type: System.AggregateException
    commentId: T:System.AggregateException
    description: "\n<p>At least one of the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances was canceled. If a task was canceled, the <xref href=\"System.AggregateException\" data-throw-if-not-resolved=\"false\"></xref> contains an <xref href=\"System.OperationCanceledException\" data-throw-if-not-resolved=\"false\"></xref> in its <xref href=\"System.AggregateException.InnerExceptions\" data-throw-if-not-resolved=\"false\"></xref> collection.</p>\n<p>-or-</p>\n<p>An exception was thrown during the execution of at least one of the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>millisecondsTimeout</em> is a negative number other than -1, which represents an infinite time-out.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>tasks</em> argument contains a null element.</p>\n<p>-or-</p>\n<p>The <em>tasks</em> argument is an empty array.</p>\n"
  - type: System.OperationCanceledException
    commentId: T:System.OperationCanceledException
    description: "\n<p>The <em>cancellationToken</em> was canceled. </p>\n"
  nameWithType.vb: Task.WaitAll(Task(), Int32, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task(), System.Int32, System.Threading.CancellationToken)
  name.vb: WaitAll(Task(), Int32, CancellationToken)
- uid: System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)
  commentId: M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)
  id: WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: WaitAll(Task[], CancellationToken)
  nameWithType: Task.WaitAll(Task[], CancellationToken)
  fullName: System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[], System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: WaitAll
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 4979
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Waits for all of the provided <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> objects to complete execution unless the wait is cancelled. </p>\n"
  remarks: "\n<p>The <em>cancellationToken</em> argument is used to cancel the wait operation. Cancellation of the tasks is a distinct operation, and is signaled by the <xref href=\"System.AggregateException\" data-throw-if-not-resolved=\"false\"></xref> as noted above.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoOptimization)]

      public static void WaitAll(Task[] tasks, CancellationToken cancellationToken)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoOptimization)>

      Public Shared Sub WaitAll(tasks As Task(), cancellationToken As CancellationToken)
    parameters:
    - id: tasks
      type: System.Threading.Tasks.Task[]
      description: "\n<p>An array of <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances on which to wait.</p>\n"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\n<p>A <xref href=\"System.Threading.Tasks.TaskFactory.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> to observe while waiting for the tasks to complete.</p>\n"
  exceptions:
  - type: System.OperationCanceledException
    commentId: T:System.OperationCanceledException
    description: "\n<p>The <em>cancellationToken</em> was canceled. </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>tasks</em> argument is <strong>null</strong>.</p>\n"
  - type: System.AggregateException
    commentId: T:System.AggregateException
    description: "\n<p>At least one of the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances was canceled. If a task was canceled, the <xref href=\"System.AggregateException\" data-throw-if-not-resolved=\"false\"></xref> contains an <xref href=\"System.OperationCanceledException\" data-throw-if-not-resolved=\"false\"></xref> in its <xref href=\"System.AggregateException.InnerExceptions\" data-throw-if-not-resolved=\"false\"></xref> collection.</p>\n<p>-or-</p>\n<p>An exception was thrown during the execution of at least one of the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances. </p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>tasks</em> argument contains a null element.</p>\n<p>-or-</p>\n<p>The <em>tasks</em> argument is an empty array.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>One or more of the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> objects in <em>tasks</em> has been disposed.</p>\n"
  nameWithType.vb: Task.WaitAll(Task(), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task(), System.Threading.CancellationToken)
  name.vb: WaitAll(Task(), CancellationToken)
- uid: System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)
  commentId: M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)
  id: WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: WaitAll(Task[], TimeSpan)
  nameWithType: Task.WaitAll(Task[], TimeSpan)
  fullName: System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[], System.TimeSpan)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: WaitAll
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 4908
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Waits for all of the provided cancellable <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> objects to complete execution within a specified time interval.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoOptimization)]

      public static bool WaitAll(Task[] tasks, TimeSpan timeout)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoOptimization)>

      Public Shared Function WaitAll(tasks As Task(), timeout As TimeSpan) As Boolean
    parameters:
    - id: tasks
      type: System.Threading.Tasks.Task[]
      description: "\n<p>An array of <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances on which to wait.</p>\n"
    - id: timeout
      type: System.TimeSpan
      description: "\n<p>A <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> that represents -1 milliseconds to wait indefinitely.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if all of the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances completed execution within the allotted time; otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>One or more of the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> objects in <em>tasks</em> has been disposed.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>tasks</em> argument is <strong>null</strong>. </p>\n"
  - type: System.AggregateException
    commentId: T:System.AggregateException
    description: "\n<p>At least one of the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances was canceled. If a task was canceled, the <xref href=\"System.AggregateException\" data-throw-if-not-resolved=\"false\"></xref> contains an <xref href=\"System.OperationCanceledException\" data-throw-if-not-resolved=\"false\"></xref> in its <xref href=\"System.AggregateException.InnerExceptions\" data-throw-if-not-resolved=\"false\"></xref> collection.</p>\n<p>-or-</p>\n<p>An exception was thrown during the execution of at least one of the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>timeout</em> is a negative number other than -1 milliseconds, which represents an infinite time-out. </p>\n<p>-or-</p>\n<p>\n<em>timeout</em> is greater than <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>tasks</em> argument contains a null element.</p>\n<p>-or-</p>\n<p>The <em>tasks</em> argument is an empty array.</p>\n"
  nameWithType.vb: Task.WaitAll(Task(), TimeSpan)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task(), System.TimeSpan)
  name.vb: WaitAll(Task(), TimeSpan)
- uid: System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])
  commentId: M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])
  id: WaitAny(System.Threading.Tasks.Task[])
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: WaitAny(Task[])
  nameWithType: Task.WaitAny(Task[])
  fullName: System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: WaitAny
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 5302
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Waits for any of the provided <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> objects to complete execution.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoOptimization)]

      public static int WaitAny(params Task[] tasks)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoOptimization)>

      Public Shared Function WaitAny(ParamArray tasks As Task()) As Integer
    parameters:
    - id: tasks
      type: System.Threading.Tasks.Task[]
      description: "\n<p>An array of <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances on which to wait.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>The index of the completed <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> object in the <em>tasks</em> array.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> has been disposed.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>tasks</em> argument is <strong>null</strong>.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>tasks</em> argument contains a null element.</p>\n"
  nameWithType.vb: Task.WaitAny(Task())
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task())
  name.vb: WaitAny(Task())
- uid: System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)
  commentId: M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)
  id: WaitAny(System.Threading.Tasks.Task[],System.Int32)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: WaitAny(Task[], Int32)
  nameWithType: Task.WaitAny(Task[], Int32)
  fullName: System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[], System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: WaitAny
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 5398
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Waits for any of the provided <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> objects to complete execution within a specified number of milliseconds.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoOptimization)]

      public static int WaitAny(Task[] tasks, int millisecondsTimeout)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoOptimization)>

      Public Shared Function WaitAny(tasks As Task(), millisecondsTimeout As Integer) As Integer
    parameters:
    - id: tasks
      type: System.Threading.Tasks.Task[]
      description: "\n<p>An array of <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances on which to wait.</p>\n"
    - id: millisecondsTimeout
      type: System.Int32
      description: "\n<p>The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref> (-1) to wait indefinitely.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>The index of the completed task in the <em>tasks</em> array argument, or -1 if the timeout occurred.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> has been disposed.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>tasks</em> argument is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>millisecondsTimeout</em> is a negative number other than -1, which represents an infinite time-out.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>tasks</em> argument contains a null element.</p>\n"
  nameWithType.vb: Task.WaitAny(Task(), Int32)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task(), System.Int32)
  name.vb: WaitAny(Task(), Int32)
- uid: System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)
  commentId: M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)
  id: WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: WaitAny(Task[], Int32, CancellationToken)
  nameWithType: Task.WaitAny(Task[], Int32, CancellationToken)
  fullName: System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[], System.Int32, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: WaitAny
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 5434
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Waits for any of the provided <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> objects to complete execution within a specified number of milliseconds or until a cancellation token is cancelled.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoOptimization)]

      public static int WaitAny(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoOptimization)>

      Public Shared Function WaitAny(tasks As Task(), millisecondsTimeout As Integer, cancellationToken As CancellationToken) As Integer
    parameters:
    - id: tasks
      type: System.Threading.Tasks.Task[]
      description: "\n<p>An array of <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances on which to wait. </p>\n"
    - id: millisecondsTimeout
      type: System.Int32
      description: "\n<p>The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref> (-1) to wait indefinitely. </p>\n"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\n<p>A <xref href=\"System.Threading.Tasks.TaskFactory.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> to observe while waiting for a task to complete. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The index of the completed task in the <em>tasks</em> array argument, or -1 if the timeout occurred.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> has been disposed.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>tasks</em> argument is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>millisecondsTimeout</em> is a negative number other than -1, which represents an infinite time-out.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>tasks</em> argument contains a null element.</p>\n"
  - type: System.OperationCanceledException
    commentId: T:System.OperationCanceledException
    description: "\n<p>The <em>cancellationToken</em> was canceled. </p>\n"
  nameWithType.vb: Task.WaitAny(Task(), Int32, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task(), System.Int32, System.Threading.CancellationToken)
  name.vb: WaitAny(Task(), Int32, CancellationToken)
- uid: System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)
  commentId: M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)
  id: WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: WaitAny(Task[], CancellationToken)
  nameWithType: Task.WaitAny(Task[], CancellationToken)
  fullName: System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[], System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: WaitAny
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 5368
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Waits for any of the provided <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> objects to complete execution unless the wait is cancelled.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoOptimization)]

      public static int WaitAny(Task[] tasks, CancellationToken cancellationToken)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoOptimization)>

      Public Shared Function WaitAny(tasks As Task(), cancellationToken As CancellationToken) As Integer
    parameters:
    - id: tasks
      type: System.Threading.Tasks.Task[]
      description: "\n<p>An array of <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances on which to wait. </p>\n"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\n<p>A <xref href=\"System.Threading.Tasks.TaskFactory.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> to observe while waiting for a task to complete. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The index of the completed task in the <em>tasks</em> array argument.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> has been disposed.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>tasks</em> argument is <strong>null</strong>.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>tasks</em> argument contains a null element.</p>\n"
  - type: System.OperationCanceledException
    commentId: T:System.OperationCanceledException
    description: "\n<p>The <em>cancellationToken</em> was canceled.</p>\n"
  nameWithType.vb: Task.WaitAny(Task(), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task(), System.Threading.CancellationToken)
  name.vb: WaitAny(Task(), CancellationToken)
- uid: System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)
  commentId: M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)
  id: WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: WaitAny(Task[], TimeSpan)
  nameWithType: Task.WaitAny(Task[], TimeSpan)
  fullName: System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[], System.TimeSpan)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: WaitAny
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 5335
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Waits for any of the provided <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> objects to complete execution within a specified time interval.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.NoOptimization)]

      public static int WaitAny(Task[] tasks, TimeSpan timeout)
    content.vb: >-
      <MethodImpl(MethodImplOptions.NoOptimization)>

      Public Shared Function WaitAny(tasks As Task(), timeout As TimeSpan) As Integer
    parameters:
    - id: tasks
      type: System.Threading.Tasks.Task[]
      description: "\n<p>An array of <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances on which to wait.</p>\n"
    - id: timeout
      type: System.TimeSpan
      description: "\n<p>A <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> that represents -1 milliseconds to wait indefinitely.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>The index of the completed task in the <em>tasks</em> array argument, or -1 if the timeout occurred.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> has been disposed.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>tasks</em> argument is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>timeout</em> is a negative number other than -1 milliseconds, which represents an infinite time-out. </p>\n<p>-or-</p>\n<p>\n<em>timeout</em> is greater than <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>tasks</em> argument contains a null element.</p>\n"
  nameWithType.vb: Task.WaitAny(Task(), TimeSpan)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task(), System.TimeSpan)
  name.vb: WaitAny(Task(), TimeSpan)
- uid: System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})
  commentId: M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})
  id: WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: WhenAll(IEnumerable<Task>)
  nameWithType: Task.WhenAll(IEnumerable<Task>)
  fullName: System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: WhenAll
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 5967
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a task that will complete when all of the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> objects in an enumerable collection have completed.</p>\n"
  remarks: "\n<p>The overloads of the <xref href=\"System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})\" data-throw-if-not-resolved=\"false\"></xref> method that return a <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> object are typically called when you are interested in the status of a set of tasks or in the exceptions thrown by a set of tasks. </p>\n<p>The call to <xref href=\"System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})\" data-throw-if-not-resolved=\"false\"></xref> method does not block the calling thread. </p>\n<p>If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <xref href=\"System.Threading.Tasks.TaskStatus.Faulted\" data-throw-if-not-resolved=\"false\"></xref> state,  where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks. </p>\n<p>If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <xref href=\"System.Threading.Tasks.TaskStatus.Canceled\" data-throw-if-not-resolved=\"false\"></xref> state. </p>\n<p>If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <xref href=\"System.Threading.Tasks.TaskStatus.RanToCompletion\" data-throw-if-not-resolved=\"false\"></xref> state.</p>\n<p>If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <xref href=\"System.Threading.Tasks.TaskStatus.RanToCompletion\" data-throw-if-not-resolved=\"false\"></xref> state before it's returned to the caller.  </p>\n"
  syntax:
    content: public static Task WhenAll(IEnumerable<Task> tasks)
    content.vb: Public Shared Function WhenAll(tasks As IEnumerable(Of Task)) As Task
    parameters:
    - id: tasks
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task}
      description: "\n<p>The tasks to wait on for completion.</p>\n"
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>A task that represents the completion of all of the supplied tasks. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>tasks</em> argument was <strong>null</strong>. </p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>tasks</em> collection contained a <strong>null</strong> task.</p>\n"
  nameWithType.vb: Task.WhenAll(IEnumerable(Of Task))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.Task))
  name.vb: WhenAll(IEnumerable(Of Task))
- uid: System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])
  commentId: M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])
  id: WhenAll(System.Threading.Tasks.Task[])
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: WhenAll(Task[])
  nameWithType: Task.WhenAll(Task[])
  fullName: System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: WhenAll
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 6030
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a task that will complete when all of the <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> objects in an array have completed. </p>\n"
  remarks: "\n<p>The overloads of the <xref href=\"System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})\" data-throw-if-not-resolved=\"false\"></xref> method that return a <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> object are typically called when you are interested in the status of a set of tasks or in the exceptions thrown by a set of tasks. </p>\n<p>The call to <xref href=\"System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])\" data-throw-if-not-resolved=\"false\"></xref> method does not block the calling thread. </p>\n<p>If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <xref href=\"System.Threading.Tasks.TaskStatus.Faulted\" data-throw-if-not-resolved=\"false\"></xref> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks. </p>\n<p>If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <xref href=\"System.Threading.Tasks.TaskStatus.Canceled\" data-throw-if-not-resolved=\"false\"></xref> state. </p>\n<p>If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <xref href=\"System.Threading.Tasks.TaskStatus.RanToCompletion\" data-throw-if-not-resolved=\"false\"></xref> state.</p>\n<p>If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <xref href=\"System.Threading.Tasks.TaskStatus.RanToCompletion\" data-throw-if-not-resolved=\"false\"></xref> state before it's returned to the caller. </p>\n"
  syntax:
    content: public static Task WhenAll(params Task[] tasks)
    content.vb: Public Shared Function WhenAll(ParamArray tasks As Task()) As Task
    parameters:
    - id: tasks
      type: System.Threading.Tasks.Task[]
      description: "\n<p>The tasks to wait on for completion.</p>\n"
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>A task that represents the completion of all of the supplied tasks.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>tasks</em> argument was <strong>null</strong>. </p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>tasks</em> array contained a <strong>null</strong> task. </p>\n"
  nameWithType.vb: Task.WhenAll(Task())
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task())
  name.vb: WhenAll(Task())
- uid: System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})
  commentId: M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})
  id: WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: WhenAll<TResult>(IEnumerable<Task<TResult>>)
  nameWithType: Task.WhenAll<TResult>(IEnumerable<Task<TResult>>)
  fullName: System.Threading.Tasks.Task.WhenAll<TResult>(System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<TResult>>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: WhenAll
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 6218
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a task that will complete when all of the <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref> objects in an enumerable collection have completed. </p>\n"
  remarks: "\n<p>The call to <xref href=\"System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})\" data-throw-if-not-resolved=\"false\"></xref> method does not block the calling thread. However, a call to the returned <xref href=\"System.Threading.Tasks.Task`1.Result\" data-throw-if-not-resolved=\"false\"></xref> property does block the calling thread.</p>\n<p>If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <xref href=\"System.Threading.Tasks.TaskStatus.Faulted\" data-throw-if-not-resolved=\"false\"></xref> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</p>\n<p>If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <xref href=\"System.Threading.Tasks.TaskStatus.Canceled\" data-throw-if-not-resolved=\"false\"></xref> state. </p>\n<p>If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <xref href=\"System.Threading.Tasks.TaskStatus.RanToCompletion\" data-throw-if-not-resolved=\"false\"></xref> state.  The <xref href=\"System.Threading.Tasks.Task`1.Result\" data-throw-if-not-resolved=\"false\"></xref> property of the returned task will be set to an array containing all of the results of the supplied tasks in the same order as they were provided (e.g. if the input tasks array contained t1, t2, t3, the output task's <xref href=\"System.Threading.Tasks.Task`1.Result\" data-throw-if-not-resolved=\"false\"></xref> property will return an <strong>TResult[]</strong> where <code>arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)</code>. </p>\n<p>If the <em>tasks</em> argument contains no tasks, the returned task will immediately transition to a <xref href=\"System.Threading.Tasks.TaskStatus.RanToCompletion\" data-throw-if-not-resolved=\"false\"></xref> state before it's returned to the caller. The returned <strong>TResult[]</strong> will be an array of 0 elements. </p>\n"
  syntax:
    content: public static Task<TResult[]> WhenAll<TResult>(IEnumerable<Task<TResult>> tasks)
    content.vb: Public Shared Function WhenAll(Of TResult)(tasks As IEnumerable(Of Task(Of TResult))) As Task(Of TResult())
    parameters:
    - id: tasks
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{{TResult}}}
      description: "\n<p>The tasks to wait on for completion. </p>\n"
    typeParameters:
    - id: TResult
      description: "\n<p>The type of the completed task. </p>\n"
    return:
      type: System.Threading.Tasks.Task{{TResult}[]}
      description: "\n<p>A task that represents the completion of all of the supplied tasks. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>tasks</em> argument was <strong>null</strong>.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>tasks</em> collection contained a <strong>null</strong> task. </p>\n"
  nameWithType.vb: Task.WhenAll(Of TResult)(IEnumerable(Of Task(Of TResult)))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.WhenAll(Of TResult)(System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.Task(Of TResult)))
  name.vb: WhenAll(Of TResult)(IEnumerable(Of Task(Of TResult)))
- uid: System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])
  commentId: M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])
  id: WhenAll``1(System.Threading.Tasks.Task{``0}[])
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: WhenAll<TResult>(Task<TResult>[])
  nameWithType: Task.WhenAll<TResult>(Task<TResult>[])
  fullName: System.Threading.Tasks.Task.WhenAll<TResult>(System.Threading.Tasks.Task<TResult>[])
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: WhenAll
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 6284
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a task that will complete when all of the <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref> objects in an array have completed. </p>\n"
  remarks: "\n<p>The call to <xref href=\"System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])\" data-throw-if-not-resolved=\"false\"></xref> method does not block the calling thread. However, a call to the returned <xref href=\"System.Threading.Tasks.Task`1.Result\" data-throw-if-not-resolved=\"false\"></xref> property does block the calling thread.</p>\n<p>If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <xref href=\"System.Threading.Tasks.TaskStatus.Faulted\" data-throw-if-not-resolved=\"false\"></xref> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks. </p>\n<p>If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <xref href=\"System.Threading.Tasks.TaskStatus.Canceled\" data-throw-if-not-resolved=\"false\"></xref> state. </p>\n<p>If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <xref href=\"System.Threading.Tasks.TaskStatus.RanToCompletion\" data-throw-if-not-resolved=\"false\"></xref> state.  The <xref href=\"System.Threading.Tasks.Task`1.Result\" data-throw-if-not-resolved=\"false\"></xref> of the returned task will be set to an array containing all of the results of the supplied tasks in the same order as they were provided (e.g. if the input tasks array contained t1, t2, t3, the output   task's <xref href=\"System.Threading.Tasks.Task`1.Result\" data-throw-if-not-resolved=\"false\"></xref> will return an <strong>TResult[]</strong> where <code>arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)</code>. </p>\n<p>If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <xref href=\"System.Threading.Tasks.TaskStatus.RanToCompletion\" data-throw-if-not-resolved=\"false\"></xref> state before it's returned to the caller.  The returned <strong>TResult[]</strong> will be an array of 0 elements. </p>\n"
  syntax:
    content: public static Task<TResult[]> WhenAll<TResult>(params Task<TResult>[] tasks)
    content.vb: Public Shared Function WhenAll(Of TResult)(ParamArray tasks As Task(Of TResult)()) As Task(Of TResult())
    parameters:
    - id: tasks
      type: System.Threading.Tasks.Task{{TResult}}[]
      description: "\n<p>The tasks to wait on for completion.</p>\n"
    typeParameters:
    - id: TResult
      description: "\n<p>The type of the completed task.</p>\n"
    return:
      type: System.Threading.Tasks.Task{{TResult}[]}
      description: "\n<p>A task that represents the completion of all of the supplied tasks.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>tasks</em> argument was <strong>null</strong>.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>tasks</em> array contained a <strong>null</strong> task.</p>\n"
  nameWithType.vb: Task.WhenAll(Of TResult)(Task(Of TResult)())
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.WhenAll(Of TResult)(System.Threading.Tasks.Task(Of TResult)())
  name.vb: WhenAll(Of TResult)(Task(Of TResult)())
- uid: System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})
  commentId: M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})
  id: WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: WhenAny(IEnumerable<Task>)
  nameWithType: Task.WhenAny(IEnumerable<Task>)
  fullName: System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: WhenAny
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 6496
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a task that will complete when any of the supplied tasks have completed.</p>\n"
  remarks: "\n<p>The returned task will complete when any of the supplied tasks has completed.  The returned task will always end in the <strong>RanToCompletion</strong> state  with its Result set to the first task to complete.  This is true even if the first task to complete ended in the <strong>Canceled</strong> or <strong>Faulted</strong> state.</p>\n"
  syntax:
    content: public static Task<Task> WhenAny(IEnumerable<Task> tasks)
    content.vb: Public Shared Function WhenAny(tasks As IEnumerable(Of Task)) As Task(Of Task)
    parameters:
    - id: tasks
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task}
      description: "\n<p>The tasks to wait on for completion.</p>\n"
    return:
      type: System.Threading.Tasks.Task{System.Threading.Tasks.Task}
      description: "\n<p>A task that represents the completion of one of the supplied tasks.  The return task's Result is the task that completed.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>tasks</em> argument was <strong>null</strong>.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>tasks</em> array contained a null task, or was empty.</p>\n"
  nameWithType.vb: Task.WhenAny(IEnumerable(Of Task))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.Task))
  name.vb: WhenAny(IEnumerable(Of Task))
- uid: System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])
  commentId: M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])
  id: WhenAny(System.Threading.Tasks.Task[])
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: WhenAny(Task[])
  nameWithType: Task.WhenAny(Task[])
  fullName: System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: WhenAny
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 6457
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a task that will complete when any of the supplied tasks have completed.</p>\n"
  remarks: "\n<p>The returned task will complete when any of the supplied tasks has completed.  The returned task will always end in the <strong>RanToCompletion</strong> state   with its <strong>Result</strong> set to the first task to complete.  This is true even if the first task to complete ended in the <strong>Canceled</strong> or <strong>Faulted</strong> state.</p>\n"
  syntax:
    content: public static Task<Task> WhenAny(params Task[] tasks)
    content.vb: Public Shared Function WhenAny(ParamArray tasks As Task()) As Task(Of Task)
    parameters:
    - id: tasks
      type: System.Threading.Tasks.Task[]
      description: "\n<p>The tasks to wait on for completion.</p>\n"
    return:
      type: System.Threading.Tasks.Task{System.Threading.Tasks.Task}
      description: "\n<p>A task that represents the completion of one of the supplied tasks.  The return task's Result is the task that completed.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>tasks</em> argument was null.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>tasks</em> array contained a null task, or was empty.</p>\n"
  nameWithType.vb: Task.WhenAny(Task())
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task())
  name.vb: WhenAny(Task())
- uid: System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})
  commentId: M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})
  id: WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: WhenAny<TResult>(IEnumerable<Task<TResult>>)
  nameWithType: Task.WhenAny<TResult>(IEnumerable<Task<TResult>>)
  fullName: System.Threading.Tasks.Task.WhenAny<TResult>(System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<TResult>>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: WhenAny
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 6563
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a task that will complete when any of the supplied tasks have completed.</p>\n"
  remarks: "\n<p>The returned task will complete when any of the supplied tasks has completed.  The returned task will always end in the RanToCompletion state with its Result set to the first task to complete. This is true even if the first task to complete ended in the Canceled or Faulted state.</p>\n"
  syntax:
    content: public static Task<Task<TResult>> WhenAny<TResult>(IEnumerable<Task<TResult>> tasks)
    content.vb: Public Shared Function WhenAny(Of TResult)(tasks As IEnumerable(Of Task(Of TResult))) As Task(Of Task(Of TResult))
    parameters:
    - id: tasks
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{{TResult}}}
      description: "\n<p>The tasks to wait on for completion.</p>\n"
    typeParameters:
    - id: TResult
      description: "\n<p>The type of the completed task.</p>\n"
    return:
      type: System.Threading.Tasks.Task{System.Threading.Tasks.Task{{TResult}}}
      description: "\n<p>A task that represents the completion of one of the supplied tasks.  The return task's Result is the task that completed.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>tasks</em> argument was <strong>null</strong>.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>tasks</em> array contained a null task, or was empty.</p>\n"
  nameWithType.vb: Task.WhenAny(Of TResult)(IEnumerable(Of Task(Of TResult)))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.WhenAny(Of TResult)(System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.Task(Of TResult)))
  name.vb: WhenAny(Of TResult)(IEnumerable(Of Task(Of TResult)))
- uid: System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])
  commentId: M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])
  id: WhenAny``1(System.Threading.Tasks.Task{``0}[])
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: WhenAny<TResult>(Task<TResult>[])
  nameWithType: Task.WhenAny<TResult>(Task<TResult>[])
  fullName: System.Threading.Tasks.Task.WhenAny<TResult>(System.Threading.Tasks.Task<TResult>[])
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: WhenAny
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 6534
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a task that will complete when any of the supplied tasks have completed.</p>\n"
  remarks: "\n<p>The returned task will complete when any of the supplied tasks has completed.  The returned task will always end in the RanToCompletion state with its Result set to the first task to complete. This is true even if the first task to complete ended in the Canceled or Faulted state.</p>\n"
  syntax:
    content: public static Task<Task<TResult>> WhenAny<TResult>(params Task<TResult>[] tasks)
    content.vb: Public Shared Function WhenAny(Of TResult)(ParamArray tasks As Task(Of TResult)()) As Task(Of Task(Of TResult))
    parameters:
    - id: tasks
      type: System.Threading.Tasks.Task{{TResult}}[]
      description: "\n<p>The tasks to wait on for completion.</p>\n"
    typeParameters:
    - id: TResult
      description: "\n<p>The type of the completed task.</p>\n"
    return:
      type: System.Threading.Tasks.Task{System.Threading.Tasks.Task{{TResult}}}
      description: "\n<p>A task that represents the completion of one of the supplied tasks.  The return task's Result is the task that completed.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>tasks</em> argument was null.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>tasks</em> array contained a null task, or was empty.</p>\n"
  nameWithType.vb: Task.WhenAny(Of TResult)(Task(Of TResult)())
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Tasks.Task.WhenAny(Of TResult)(System.Threading.Tasks.Task(Of TResult)())
  name.vb: WhenAny(Of TResult)(Task(Of TResult)())
- uid: System.Threading.Tasks.Task.Yield
  commentId: M:System.Threading.Tasks.Task.Yield
  id: Yield
  parent: System.Threading.Tasks.Task
  langs:
  - csharp
  - vb
  name: Yield()
  nameWithType: Task.Yield()
  fullName: System.Threading.Tasks.Task.Yield()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/Task.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Yield
    path: src/mscorlib/src/System/Threading/Tasks/Task.cs
    startLine: 3000
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates an awaitable task that asynchronously yields back to the current context when awaited.</p>\n"
  remarks: "\n<p>You can use <code>await Task.Yield();</code> in an asynchronous method to force the method to complete asynchronously. If there is a current synchronization context (<xref href=\"System.Threading.SynchronizationContext\" data-throw-if-not-resolved=\"false\"></xref> object), this will post the remainder of the methods execution back to that context. However, the context will decide how to prioritize this work relative to other work that may be pending. The synchronization context that is present on a UI thread in most UI environments will often prioritize work posted to the context higher than input and rendering work. For this reason, do not rely on <code>await Task.Yield();</code> to keep a UI responsive.  For more information, see the entry <see href=\"http://blogs.msdn.com/b/pfxteam/archive/2008/07/23/8768673.aspx\">Useful Abstractions Enabled with ContinueWith</see> in the Parallel Programming with .NET blog.</p>\n"
  syntax:
    content: public static YieldAwaitable Yield()
    content.vb: Public Shared Function Yield As YieldAwaitable
    return:
      type: System.Runtime.CompilerServices.YieldAwaitable
      description: "\n<p>A context that, when awaited, will asynchronously transition back into the current context at the time of the await. If the current <xref href=\"System.Threading.SynchronizationContext\" data-throw-if-not-resolved=\"false\"></xref> is non-null, it is treated as the current context. Otherwise, the task scheduler that is associated with the currently executing task is treated as the current context. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
references:
- uid: System.Threading.Tasks
  isExternal: false
  name: System.Threading.Tasks
  nameWithType: System.Threading.Tasks
  fullName: System.Threading.Tasks
  commentId: N:System.Threading.Tasks
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  nameWithType: Object
  fullName: System.Object
  commentId: T:System.Object
- uid: System.IAsyncResult
  parent: System
  isExternal: false
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
  commentId: T:System.IAsyncResult
- uid: System.Object.ToString
  parent: System.Object
  isExternal: true
  name: ToString()
  nameWithType: Object.ToString()
  fullName: System.Object.ToString()
  spec.csharp:
  - uid: System.Object.ToString
    name: ToString
    nameWithType: Object.ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.ToString
    name: ToString
    nameWithType: Object.ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  commentId: M:System.Object.ToString
- uid: System.Object.Equals(System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object)
  nameWithType: Object.Equals(Object)
  fullName: System.Object.Equals(System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  commentId: M:System.Object.Equals(System.Object)
- uid: System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object, Object)
  nameWithType: Object.Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  commentId: M:System.Object.Equals(System.Object,System.Object)
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: ReferenceEquals(Object, Object)
  nameWithType: Object.ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    nameWithType: Object.ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    nameWithType: Object.ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  commentId: M:System.Object.ReferenceEquals(System.Object,System.Object)
- uid: System.Object.GetHashCode
  parent: System.Object
  isExternal: true
  name: GetHashCode()
  nameWithType: Object.GetHashCode()
  fullName: System.Object.GetHashCode()
  spec.csharp:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    nameWithType: Object.GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    nameWithType: Object.GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  commentId: M:System.Object.GetHashCode
- uid: System.Object.GetType
  parent: System.Object
  isExternal: true
  name: GetType()
  nameWithType: Object.GetType()
  fullName: System.Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    nameWithType: Object.GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    nameWithType: Object.GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  commentId: M:System.Object.GetType
- uid: System.Object.MemberwiseClone
  parent: System.Object
  isExternal: true
  name: MemberwiseClone()
  nameWithType: Object.MemberwiseClone()
  fullName: System.Object.MemberwiseClone()
  spec.csharp:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    nameWithType: Object.MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    nameWithType: Object.MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  commentId: M:System.Object.MemberwiseClone
- uid: System
  isExternal: false
  name: System
  nameWithType: System
  fullName: System
  commentId: N:System
- uid: System.Action
  parent: System
  isExternal: false
  name: Action
  nameWithType: Action
  fullName: System.Action
  commentId: T:System.Action
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: false
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
  commentId: T:System.Threading.CancellationToken
- uid: System.Threading
  isExternal: false
  name: System.Threading
  nameWithType: System.Threading
  fullName: System.Threading
  commentId: N:System.Threading
- uid: System.Threading.Tasks.TaskCreationOptions
  parent: System.Threading.Tasks
  isExternal: false
  name: TaskCreationOptions
  nameWithType: TaskCreationOptions
  fullName: System.Threading.Tasks.TaskCreationOptions
  commentId: T:System.Threading.Tasks.TaskCreationOptions
- uid: System.Action{System.Object}
  parent: System
  definition: System.Action`1
  name: Action<Object>
  nameWithType: Action<Object>
  fullName: System.Action<System.Object>
  nameWithType.vb: Action(Of Object)
  fullname.vb: System.Action(Of System.Object)
  name.vb: Action(Of Object)
  spec.csharp:
  - uid: System.Action`1
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Action`1
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  commentId: T:System.Action{System.Object}
- uid: System.Action`1
  isExternal: false
  name: Action<T>
  nameWithType: Action<T>
  fullName: System.Action<T>
  nameWithType.vb: Action(Of T)
  fullname.vb: System.Action(Of T)
  name.vb: Action(Of T)
  spec.csharp:
  - uid: System.Action`1
    name: Action
    nameWithType: Action
    fullName: System.Action
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Action`1
    name: Action
    nameWithType: Action
    fullName: System.Action
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
  commentId: T:System.Action`1
- uid: System.IAsyncResult.AsyncState
  parent: System.IAsyncResult
  isExternal: true
  name: AsyncState
  nameWithType: IAsyncResult.AsyncState
  fullName: System.IAsyncResult.AsyncState
  commentId: P:System.IAsyncResult.AsyncState
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: false
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
  commentId: T:System.Threading.Tasks.Task
- uid: System.Nullable{System.Int32}
  parent: System
  definition: System.Nullable`1
  name: Nullable<Int32>
  nameWithType: Nullable<Int32>
  fullName: System.Nullable<System.Int32>
  nameWithType.vb: Nullable(Of Int32)
  fullname.vb: System.Nullable(Of System.Int32)
  name.vb: Nullable(Of Int32)
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    nameWithType: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: System.Int32
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Nullable`1
    name: Nullable
    nameWithType: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: System.Int32
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  commentId: T:System.Nullable{System.Int32}
- uid: System.Nullable`1
  parent: System
  isExternal: false
  name: Nullable<T>
  nameWithType: Nullable<T>
  fullName: System.Nullable<T>
  nameWithType.vb: Nullable(Of T)
  fullname.vb: System.Nullable(Of T)
  name.vb: Nullable(Of T)
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    nameWithType: Nullable
    fullName: System.Nullable
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Nullable`1
    name: Nullable
    nameWithType: Nullable
    fullName: System.Nullable
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
  commentId: T:System.Nullable`1
- uid: System.AggregateException
  parent: System
  isExternal: false
  name: AggregateException
  nameWithType: AggregateException
  fullName: System.AggregateException
  commentId: T:System.AggregateException
- uid: System.Threading.Tasks.TaskFactory
  parent: System.Threading.Tasks
  isExternal: false
  name: TaskFactory
  nameWithType: TaskFactory
  fullName: System.Threading.Tasks.TaskFactory
  commentId: T:System.Threading.Tasks.TaskFactory
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
  commentId: T:System.Int32
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
  commentId: T:System.Boolean
- uid: System.IAsyncResult.IsCompleted
  parent: System.IAsyncResult
  isExternal: true
  name: IsCompleted
  nameWithType: IAsyncResult.IsCompleted
  fullName: System.IAsyncResult.IsCompleted
  commentId: P:System.IAsyncResult.IsCompleted
- uid: System.Threading.Tasks.TaskStatus
  parent: System.Threading.Tasks
  isExternal: false
  name: TaskStatus
  nameWithType: TaskStatus
  fullName: System.Threading.Tasks.TaskStatus
  commentId: T:System.Threading.Tasks.TaskStatus
- uid: System.IAsyncResult.AsyncWaitHandle
  parent: System.IAsyncResult
  isExternal: true
  name: AsyncWaitHandle
  nameWithType: IAsyncResult.AsyncWaitHandle
  fullName: System.IAsyncResult.AsyncWaitHandle
  commentId: P:System.IAsyncResult.AsyncWaitHandle
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: false
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle
  commentId: T:System.Threading.WaitHandle
- uid: System.IAsyncResult.CompletedSynchronously
  parent: System.IAsyncResult
  isExternal: true
  name: CompletedSynchronously
  nameWithType: IAsyncResult.CompletedSynchronously
  fullName: System.IAsyncResult.CompletedSynchronously
  commentId: P:System.IAsyncResult.CompletedSynchronously
- uid: System.Runtime.CompilerServices.ConfiguredTaskAwaitable
  parent: System.Runtime.CompilerServices
  isExternal: false
  name: ConfiguredTaskAwaitable
  nameWithType: ConfiguredTaskAwaitable
  fullName: System.Runtime.CompilerServices.ConfiguredTaskAwaitable
  commentId: T:System.Runtime.CompilerServices.ConfiguredTaskAwaitable
- uid: System.Runtime.CompilerServices
  isExternal: false
  name: System.Runtime.CompilerServices
  nameWithType: System.Runtime.CompilerServices
  fullName: System.Runtime.CompilerServices
  commentId: N:System.Runtime.CompilerServices
- uid: System.Action{System.Threading.Tasks.Task,System.Object}
  parent: System
  definition: System.Action`2
  name: Action<Task, Object>
  nameWithType: Action<Task, Object>
  fullName: System.Action<System.Threading.Tasks.Task, System.Object>
  nameWithType.vb: Action(Of Task, Object)
  fullname.vb: System.Action(Of System.Threading.Tasks.Task, System.Object)
  name.vb: Action(Of Task, Object)
  spec.csharp:
  - uid: System.Action`2
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Action`2
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  commentId: T:System.Action{System.Threading.Tasks.Task,System.Object}
- uid: System.Action`2
  isExternal: false
  name: Action<T1, T2>
  nameWithType: Action<T1, T2>
  fullName: System.Action<T1, T2>
  nameWithType.vb: Action(Of T1, T2)
  fullname.vb: System.Action(Of T1, T2)
  name.vb: Action(Of T1, T2)
  spec.csharp:
  - uid: System.Action`2
    name: Action
    nameWithType: Action
    fullName: System.Action
  - name: <
    nameWithType: <
    fullName: <
  - name: T1
    nameWithType: T1
    fullName: T1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: T2
    nameWithType: T2
    fullName: T2
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Action`2
    name: Action
    nameWithType: Action
    fullName: System.Action
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T1
    nameWithType: T1
    fullName: T1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: T2
    nameWithType: T2
    fullName: T2
  - name: )
    nameWithType: )
    fullName: )
  commentId: T:System.Action`2
- uid: System.Threading.Tasks.TaskContinuationOptions
  parent: System.Threading.Tasks
  isExternal: false
  name: TaskContinuationOptions
  nameWithType: TaskContinuationOptions
  fullName: System.Threading.Tasks.TaskContinuationOptions
  commentId: T:System.Threading.Tasks.TaskContinuationOptions
- uid: System.Threading.Tasks.TaskScheduler
  parent: System.Threading.Tasks
  isExternal: false
  name: TaskScheduler
  nameWithType: TaskScheduler
  fullName: System.Threading.Tasks.TaskScheduler
  commentId: T:System.Threading.Tasks.TaskScheduler
- uid: System.Action{System.Threading.Tasks.Task}
  parent: System
  definition: System.Action`1
  name: Action<Task>
  nameWithType: Action<Task>
  fullName: System.Action<System.Threading.Tasks.Task>
  nameWithType.vb: Action(Of Task)
  fullname.vb: System.Action(Of System.Threading.Tasks.Task)
  name.vb: Action(Of Task)
  spec.csharp:
  - uid: System.Action`1
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Action`1
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: )
    nameWithType: )
    fullName: )
  commentId: T:System.Action{System.Threading.Tasks.Task}
- uid: System.Func{System.Threading.Tasks.Task,{TResult}}
  parent: System
  definition: System.Func`2
  name: Func<Task, TResult>
  nameWithType: Func<Task, TResult>
  fullName: System.Func<System.Threading.Tasks.Task, TResult>
  nameWithType.vb: Func(Of Task, TResult)
  fullname.vb: System.Func(Of System.Threading.Tasks.Task, TResult)
  name.vb: Func(Of Task, TResult)
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
  commentId: T:System.Func{System.Threading.Tasks.Task,``0}
- uid: System.Threading.Tasks.Task{{TResult}}
  parent: System.Threading.Tasks
  definition: System.Threading.Tasks.Task`1
  name: Task<TResult>
  nameWithType: Task<TResult>
  fullName: System.Threading.Tasks.Task<TResult>
  nameWithType.vb: Task(Of TResult)
  fullname.vb: System.Threading.Tasks.Task(Of TResult)
  name.vb: Task(Of TResult)
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: <
    nameWithType: <
    fullName: <
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
  commentId: T:System.Threading.Tasks.Task{`0}
- uid: System.Func`2
  isExternal: false
  name: Func<T, TResult>
  nameWithType: Func<T, TResult>
  fullName: System.Func<T, TResult>
  nameWithType.vb: Func(Of T, TResult)
  fullname.vb: System.Func(Of T, TResult)
  name.vb: Func(Of T, TResult)
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
  commentId: T:System.Func`2
- uid: System.Threading.Tasks.Task`1
  isExternal: false
  name: Task<TResult>
  nameWithType: Task<TResult>
  fullName: System.Threading.Tasks.Task<TResult>
  nameWithType.vb: Task(Of TResult)
  fullname.vb: System.Threading.Tasks.Task(Of TResult)
  name.vb: Task(Of TResult)
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: <
    nameWithType: <
    fullName: <
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
  commentId: T:System.Threading.Tasks.Task`1
- uid: System.Func{System.Threading.Tasks.Task,System.Object,{TResult}}
  parent: System
  definition: System.Func`3
  name: Func<Task, Object, TResult>
  nameWithType: Func<Task, Object, TResult>
  fullName: System.Func<System.Threading.Tasks.Task, System.Object, TResult>
  nameWithType.vb: Func(Of Task, Object, TResult)
  fullname.vb: System.Func(Of System.Threading.Tasks.Task, System.Object, TResult)
  name.vb: Func(Of Task, Object, TResult)
  spec.csharp:
  - uid: System.Func`3
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`3
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
  commentId: T:System.Func{System.Threading.Tasks.Task,System.Object,``0}
- uid: System.Func`3
  isExternal: false
  name: Func<T1, T2, TResult>
  nameWithType: Func<T1, T2, TResult>
  fullName: System.Func<T1, T2, TResult>
  nameWithType.vb: Func(Of T1, T2, TResult)
  fullname.vb: System.Func(Of T1, T2, TResult)
  name.vb: Func(Of T1, T2, TResult)
  spec.csharp:
  - uid: System.Func`3
    name: Func
    nameWithType: Func
    fullName: System.Func
  - name: <
    nameWithType: <
    fullName: <
  - name: T1
    nameWithType: T1
    fullName: T1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: T2
    nameWithType: T2
    fullName: T2
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`3
    name: Func
    nameWithType: Func
    fullName: System.Func
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T1
    nameWithType: T1
    fullName: T1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: T2
    nameWithType: T2
    fullName: T2
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
  commentId: T:System.Func`3
- uid: System.TimeSpan
  parent: System
  isExternal: false
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
  commentId: T:System.TimeSpan
- uid: System.Exception
  parent: System
  isExternal: false
  name: Exception
  nameWithType: Exception
  fullName: System.Exception
  commentId: T:System.Exception
- uid: '{TResult}'
  definition: TResult
  name: TResult
  nameWithType: TResult
  fullName: TResult
  commentId: '!:TResult'
- uid: TResult
  isExternal: false
  name: TResult
  nameWithType: TResult
  fullName: TResult
- uid: System.Runtime.CompilerServices.TaskAwaiter
  parent: System.Runtime.CompilerServices
  isExternal: false
  name: TaskAwaiter
  nameWithType: TaskAwaiter
  fullName: System.Runtime.CompilerServices.TaskAwaiter
  commentId: T:System.Runtime.CompilerServices.TaskAwaiter
- uid: System.Func{System.Threading.Tasks.Task}
  parent: System
  definition: System.Func`1
  name: Func<Task>
  nameWithType: Func<Task>
  fullName: System.Func<System.Threading.Tasks.Task>
  nameWithType.vb: Func(Of Task)
  fullname.vb: System.Func(Of System.Threading.Tasks.Task)
  name.vb: Func(Of Task)
  spec.csharp:
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: )
    nameWithType: )
    fullName: )
  commentId: T:System.Func{System.Threading.Tasks.Task}
- uid: System.Func`1
  isExternal: false
  name: Func<TResult>
  nameWithType: Func<TResult>
  fullName: System.Func<TResult>
  nameWithType.vb: Func(Of TResult)
  fullname.vb: System.Func(Of TResult)
  name.vb: Func(Of TResult)
  spec.csharp:
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: System.Func
  - name: <
    nameWithType: <
    fullName: <
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: System.Func
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
  commentId: T:System.Func`1
- uid: System.Func{{TResult}}
  parent: System
  definition: System.Func`1
  name: Func<TResult>
  nameWithType: Func<TResult>
  fullName: System.Func<TResult>
  nameWithType.vb: Func(Of TResult)
  fullname.vb: System.Func(Of TResult)
  name.vb: Func(Of TResult)
  spec.csharp:
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
  commentId: T:System.Func{``0}
- uid: System.Func{System.Threading.Tasks.Task{{TResult}}}
  parent: System
  definition: System.Func`1
  name: Func<Task<TResult>>
  nameWithType: Func<Task<TResult>>
  fullName: System.Func<System.Threading.Tasks.Task<TResult>>
  nameWithType.vb: Func(Of Task(Of TResult))
  fullname.vb: System.Func(Of System.Threading.Tasks.Task(Of TResult))
  name.vb: Func(Of Task(Of TResult))
  spec.csharp:
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: <
    nameWithType: <
    fullName: <
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
  commentId: T:System.Func{System.Threading.Tasks.Task{``0}}
- uid: System.Threading.Tasks.Task[]
  name: Task[]
  nameWithType: Task[]
  fullName: System.Threading.Tasks.Task[]
  nameWithType.vb: Task()
  fullname.vb: System.Threading.Tasks.Task()
  name.vb: Task()
  spec.csharp:
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: ()
    nameWithType: ()
    fullName: ()
- uid: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<Task>
  nameWithType: IEnumerable<Task>
  fullName: System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task>
  nameWithType.vb: IEnumerable(Of Task)
  fullname.vb: System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.Task)
  name.vb: IEnumerable(Of Task)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: )
    nameWithType: )
    fullName: )
  commentId: T:System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task}
- uid: System.Collections.Generic.IEnumerable`1
  isExternal: false
  name: IEnumerable<T>
  nameWithType: IEnumerable<T>
  fullName: System.Collections.Generic.IEnumerable<T>
  nameWithType.vb: IEnumerable(Of T)
  fullname.vb: System.Collections.Generic.IEnumerable(Of T)
  name.vb: IEnumerable(Of T)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
  commentId: T:System.Collections.Generic.IEnumerable`1
- uid: System.Collections.Generic
  isExternal: false
  name: System.Collections.Generic
  nameWithType: System.Collections.Generic
  fullName: System.Collections.Generic
  commentId: N:System.Collections.Generic
- uid: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{{TResult}}}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<Task<TResult>>
  nameWithType: IEnumerable<Task<TResult>>
  fullName: System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<TResult>>
  nameWithType.vb: IEnumerable(Of Task(Of TResult))
  fullname.vb: System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.Task(Of TResult))
  name.vb: IEnumerable(Of Task(Of TResult))
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: <
    nameWithType: <
    fullName: <
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
  commentId: T:System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}}
- uid: System.Threading.Tasks.Task{{TResult}[]}
  parent: System.Threading.Tasks
  definition: System.Threading.Tasks.Task`1
  name: Task<TResult[]>
  nameWithType: Task<TResult[]>
  fullName: System.Threading.Tasks.Task<TResult[]>
  nameWithType.vb: Task(Of TResult())
  fullname.vb: System.Threading.Tasks.Task(Of TResult())
  name.vb: Task(Of TResult())
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: <
    nameWithType: <
    fullName: <
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: ()
    nameWithType: ()
    fullName: ()
  - name: )
    nameWithType: )
    fullName: )
  commentId: T:System.Threading.Tasks.Task{``0[]}
- uid: System.Threading.Tasks.Task{{TResult}}[]
  name: Task<TResult>[]
  nameWithType: Task<TResult>[]
  fullName: System.Threading.Tasks.Task<TResult>[]
  nameWithType.vb: Task(Of TResult)()
  fullname.vb: System.Threading.Tasks.Task(Of TResult)()
  name.vb: Task(Of TResult)()
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: <
    nameWithType: <
    fullName: <
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
  - name: ()
    nameWithType: ()
    fullName: ()
- uid: System.Threading.Tasks.Task{System.Threading.Tasks.Task}
  parent: System.Threading.Tasks
  definition: System.Threading.Tasks.Task`1
  name: Task<Task>
  nameWithType: Task<Task>
  fullName: System.Threading.Tasks.Task<System.Threading.Tasks.Task>
  nameWithType.vb: Task(Of Task)
  fullname.vb: System.Threading.Tasks.Task(Of System.Threading.Tasks.Task)
  name.vb: Task(Of Task)
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: )
    nameWithType: )
    fullName: )
  commentId: T:System.Threading.Tasks.Task{System.Threading.Tasks.Task}
- uid: System.Threading.Tasks.Task{System.Threading.Tasks.Task{{TResult}}}
  parent: System.Threading.Tasks
  definition: System.Threading.Tasks.Task`1
  name: Task<Task<TResult>>
  nameWithType: Task<Task<TResult>>
  fullName: System.Threading.Tasks.Task<System.Threading.Tasks.Task<TResult>>
  nameWithType.vb: Task(Of Task(Of TResult))
  fullname.vb: System.Threading.Tasks.Task(Of System.Threading.Tasks.Task(Of TResult))
  name.vb: Task(Of Task(Of TResult))
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: <
    nameWithType: <
    fullName: <
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
  commentId: T:System.Threading.Tasks.Task{System.Threading.Tasks.Task{``0}}
- uid: System.Runtime.CompilerServices.YieldAwaitable
  parent: System.Runtime.CompilerServices
  isExternal: false
  name: YieldAwaitable
  nameWithType: YieldAwaitable
  fullName: System.Runtime.CompilerServices.YieldAwaitable
  commentId: T:System.Runtime.CompilerServices.YieldAwaitable
- uid: System.ArgumentNullException
  isExternal: false
  name: ArgumentNullException
  nameWithType: ArgumentNullException
  fullName: System.ArgumentNullException
  commentId: T:System.ArgumentNullException
- uid: System.ObjectDisposedException
  isExternal: false
  name: ObjectDisposedException
  nameWithType: ObjectDisposedException
  fullName: System.ObjectDisposedException
  commentId: T:System.ObjectDisposedException
- uid: System.ArgumentOutOfRangeException
  isExternal: false
  name: ArgumentOutOfRangeException
  nameWithType: ArgumentOutOfRangeException
  fullName: System.ArgumentOutOfRangeException
  commentId: T:System.ArgumentOutOfRangeException
- uid: System.Threading.Tasks.TaskCanceledException
  isExternal: false
  name: TaskCanceledException
  nameWithType: TaskCanceledException
  fullName: System.Threading.Tasks.TaskCanceledException
  commentId: T:System.Threading.Tasks.TaskCanceledException
- uid: System.InvalidOperationException
  parent: System
  isExternal: false
  name: InvalidOperationException
  nameWithType: InvalidOperationException
  fullName: System.InvalidOperationException
  commentId: T:System.InvalidOperationException
- uid: System.Threading.Tasks.TaskSchedulerException
  isExternal: false
  name: TaskSchedulerException
  nameWithType: TaskSchedulerException
  fullName: System.Threading.Tasks.TaskSchedulerException
  commentId: T:System.Threading.Tasks.TaskSchedulerException
- uid: System.OperationCanceledException
  parent: System
  isExternal: false
  name: OperationCanceledException
  nameWithType: OperationCanceledException
  fullName: System.OperationCanceledException
  commentId: T:System.OperationCanceledException
- uid: System.ArgumentException
  parent: System
  isExternal: false
  name: ArgumentException
  nameWithType: ArgumentException
  fullName: System.ArgumentException
  commentId: T:System.ArgumentException
